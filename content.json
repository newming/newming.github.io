[{"title":"深入理解 margin collapse 及 BFC","date":"2018-03-05T04:59:18.000Z","path":"2018/03/05/margin-collapse/","text":"外边距融合对于前端的同学应该是不陌生，之前当我遇到这种问题时，可能很多人随手换个 css 属性解决后即不在思考或总结这个问题的解决办法，前几天看到这么一个讨论，发现出现了很多之前没有见过的 css 方面的名次，感觉需要去深入的了解一下这块了。 这节内容主要说明 margin collapse 及 BFC 这两个东西，主要参考 MDN 及 css tricks，Pet 的博客 的这几篇文章。 margin collapse块的顶部外边距和底部外边距有时被组合(折叠)为单个外边距，其大小是组合到其中的最大外边距，这种行为称为外边距塌陷(margin collapsing)，有的地方翻译为外边距合并。 发生外边距塌陷的三种基本情况: 相邻的兄弟姐妹元素毗邻的两个兄弟元素之间的外边距会塌陷（除非后者兄弟姐妹需要清除过去的浮动）。例如： 1 2 &lt;p style=\"margin-bottom: 30px;\"&gt;这个段落的下外边距被合并...&lt;/p&gt; &lt;p style=\"margin-top: 20px;\"&gt;...这个段落的上外边距被合并。&lt;/p&gt; 可以发现这两个段落中间的距离，不是 ”上面段落的下边距“ 与 ”下面段落的上边距“ 的 求和 ，而是两者中的较大者（在此示例中为30px）。 块级父元素与其第一个/最后一个子元素如果块级父元素中，不存在上边框、上内边距、内联元素、块格式化上下文、 清除浮动 这五条（也可以说，当上边框宽度及上内边距距离为0时），那么这个块级元素和其第一个子元素的上边距就可以说”挨到了一起“。此时这个块级父元素和其第一个子元素就会发生上外边距合并现象，换句话说，此时这个父元素对外展现出来的外边距将直接变成这个父元素和其第一个子元素的margin-top的较大者。类似的，若块级父元素的 margin-bottom 与它的最后一个子元素的margin-bottom 之间没有父元素的 border、padding、inline content、height、min-height、 max-height 分隔时，就会发生 下外边距合并 现象。 空块元素如果存在一个空的块级元素，其 border、padding、inline content、height、min-height 都不存在。那么此时它的上下边距中间将没有任何阻隔，此时它的上下外边距将会合并。例如： 1 2 3 4 5 &lt;p style=\"margin-bottom: 0px;\"&gt;这个段落的和下面段落的距离将为20px&lt;/p&gt; &lt;div style=\"margin-top: 20px; margin-bottom: 20px;\"&gt;&lt;/div&gt; &lt;p style=\"margin-top: 0px;\"&gt;这个段落的和上面段落的距离将为20px&lt;/p&gt; 当以上情形同时出现时，外边距合并会更加复杂（会比较两个以上外边距来最终计算出真实的边距值）。 即使外边距为0，这些规则也仍旧生效。因此，无论父元素的外边距是否为0，第一个或者最后一个子元素的外边距会被父元素的外边距”截断”(根据上面的规则)，在负外边距的情况下，合并后的外边距为最大正外边距与最小负外边距之和。 当有负边距存在时，合并后的外边距将是最大正边距加上最小负边距（即负边距中绝对值最大的一个）。 如两个兄弟元素，上面的元素的下边距为 20px ，下面的元素的上边距为 -20px ，那么发生外边距合并后，这两个元素的实际距离将变成 0px 。 BFC（Block Formatting Context 块格式化上下文）与元素外边距合并 : 当两个元素属于不同的BFC时，这两个元素的外边距不会合并。 但在同一个BFC内，两个相邻元素的外边距仍会合并。 具体 margin collapse 问题怎么表现，可以看 css tricks 的文章，里边有具体的例子及代码。 怎么解决呢 其实解决办法很简单，css tricks 上是用\b的 padding。其实只要存在 上边框、上内边距、内联元素、块格式化上下文、 清除浮动 这些属性，就不会有 margin collapse 问题。 块格式化上下文MDN BFC 块格式化上下文(Block Formatting Context，BFC)，是Web页面的可视化CSS渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。 创建块格式化上下文的方式如下： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素的 position 为 absolute 或 fixed) 内联块元素 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 匿名表格元素 (元素具有 display: table, table-row, table-row-group, table-header-group, table-footer-group [分别是HTML tables, table rows, table bodies, table headers and table footers的默认属性]，或 inline-table ) overflow 值不为 visible 的块元素， display 值为 flow-root 的元素 contain 值为 layout, content, 或 strict 的元素 弹性元素 (display: flex 或 inline-flex元素的子元素) 网格元素 (display: grid 或 inline-grid 元素的子元素) 多列容器 (元素的 column-count 或 column-width 不为 auto 即视为多列，column-count: 1的元素也属于多列) 即便具有 column-span: all 的元素没有被包裹在一个多列容器中，column-span: all 也始终会创建一个新的格式化上下文。 块格式化上下文包含创建它的元素内的所有内容。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 注意：Margin collapsing也只发生在属于同一块格式化上下文的块级元素之间。","tags":[{"name":"css","slug":"css","permalink":"https://newming.github.io/tags/css/"}]},{"title":"css 伪类及伪元素","date":"2018-03-02T13:00:35.000Z","path":"2018/03/02/css伪类及伪元素/","text":"前几天在用 bootstrap 4 的时候发现了 :root 这个陌生的 css 伪类，到 mdn 上一查发现了很多之前没见过的，还有 css 中竟然可以定义变量了，还有不少伪元素，其中有一些修改表单默认控件样式的，所以决定一起看一下，记一下。 css 伪类 :active: 匹配被用户激活的元素。常用于 a, button 元素 :any: mdn 文档 可以让您快速构建类似的选择器集合，通过建立包含所有包含项的组来匹配。 :any-link: 代表一个有链接锚点的元素，而不管它是否被访问过，也就是说，它会匹配每一个有 href 属性的 &lt;a&gt;、&lt;area&gt; 或 &lt;link&gt; 元素。因此，它会匹配到所有的 :link 或 :visited。 :checked: 表示任何处于选中状态的radio(&lt;input type=”radio”&gt;), checkbox (&lt;input type=”checkbox”&gt;) 或(“select”) 元素中的option HTML元素(“option”)) 。 :default: 表示一组相关元素中的默认表单元素。 :defined: 匹配定义的元素。 :dir(): 匹配包含定义文本方向的元素。可选值为 ltr(从左到右), rtl(从右到左)。例如：&lt;div dir=”ltr”&gt;test2&lt;/div&gt; :disabled: 匹配禁用元素。 :empty: 匹配任何没有子元素的元素。子元素可以是元素节点或者文本。 :enabled: 匹配没有被禁用的元素。 :first: 匹配第一个页面。与 @page 配合使用。 :first-child: 匹配一组元素中第一个元素节点。 :first-of-type: 匹配一组相邻元素中第一个所选类型元素。 :fullscreen: 匹配进入全屏的元素。 :focus: 匹配获得焦点的元素。 :focus-within: 匹配或得焦点或者其内部子元素或得焦点的元素。 :hover: 匹配鼠标移上的元素。 :indeterminate: 匹配任何状态为 indeterminate 的表单元素。 :in-range: 匹配当前的 value 没有超过可选范围的表单元素。 :invalid: 匹配任何 form 或 input 中内容不合法的元素。 :lang(): 匹配包含语言设置的元素。&lt;div lang=”en”&gt;&lt;/div&gt; :last-child: 匹配一组元素中最后一个所选元素。 :last-of-type: 匹配一组相邻元素中最后一个该类型的元素。 :left: 和 @page 配合，匹配所有按 left-hand 输出的页面。 :link: 匹配包含 href 属性的并且没有被 visited 的元素。 :not(): 匹配一系列不在选取范围的元素。 :nth-child(n): 匹配第 n 个元素。 :nth-last-child(): 从末尾开始匹配。 :nth-last-of-type(): 从末尾按类型匹配。 :nth-of-type(n): 按类型位置进行匹配。 :only-child: 匹配没有兄弟元素的元素。 :only-of-type: 匹配没有兄弟元素的符合类型的元素。 :optional: 匹配没有设置 required 的表单元素。 :out-of-range: 与 in-range 相反，匹配 value 超出范围的元素。 :placeholder-shown: 匹配当前展示出 placeholder 文本的表单。 :read-only: 匹配只读的表单元素。 &lt;input type=”text” value=”This is a read-only field.” readonly&gt; :read-write: 匹配可以读写的元素。包括 contenteditable 为 true 的元素。 :required: 匹配设置了 required 的表单元素。 :right: 与 @page 配合，匹配所有按 right-hand 输出的页面。 :root: 匹配文档的根元素，即 html。 :socpe: :target: :valid: 匹配表单 value 合法的元素。 :visited: 匹配点击过的 a 元素。 css 伪元素mdn ::moz-progress-bar: 进度条 progress 样式控制 ::moz-range-progress: input type range 的滑过进度样式 ::moz-range-thumb: input type range 的滑块样式 ::moz-range-track: input type range 的背景条样式 ::ms-browse: input type file 的 button 的样式 ::ms-check: radio, checkbox 的选框样式 ::ms-clear: IE input text 框自带 x(清除) 样式 ::ms-expand: IE select option 的样式 ::ms-fill: IE progress 的样式 ::ms-fill-lower: IE input range 的样式 ::ms-fill-upper: IE input range 的样式 ::ms-thumb: IE input range 的样式 ::ms-track: IE input range 的样式 ::ms-reveal: IE input password 的样式 ::webkit-progress-bar: progress 的样式 ::webkit-progress-value: progress 的样式 ::webkit-slider-runnable-track: input range 的样式 ::webkit-slider-thumb: input range 的样式 ::after: :after ::backdrop: ::before: :after ::cue: ::first-letter: 第一个单词 ::first-line: 第一行文本 ::grammar-error: 语法错误 ::spelling-error: 拼写错误 ::placeholder: placeholder 文本样式 ::selection: 当文本被选中时的样式 css 变量1 2 3 4 5 6 7 8 9 &lt;!-- 变量申明 --&gt; element &#123; --main-bg-color: brown; &#125; &lt;!-- 变量调用 --&gt; element &#123; background-color: var(--main-bg-color); &#125;","tags":[{"name":"css","slug":"css","permalink":"https://newming.github.io/tags/css/"}]},{"title":"js-cookie","date":"2018-01-31T02:43:36.000Z","path":"2018/01/31/js-cookie/","text":"最近做了一个需要在不同二级域名的两个项目之间进行通知，尝试了 iframe 方式，发现在移动端失败，于是打算通过 cookie 来进行消息通知。所以去找了前端操作 cookie 的库，后来找到 js-cookie 这个库。由于之前操作 cookie 的经历有限，所以特意去阅读了源码并总结。 源码如下：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 /*! * JavaScript Cookie v2.2.0 * https://github.com/js-cookie/js-cookie * * Copyright 2006, 2015 Klaus Hartl &amp; Fagner Brack * Released under the MIT license */ ;(function (factory) &#123; // 各种方式的模块定义 var registeredInModuleLoader = false; if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(factory); registeredInModuleLoader = true; &#125; if (typeof exports === 'object') &#123; module.exports = factory(); registeredInModuleLoader = true; &#125; if (!registeredInModuleLoader) &#123; var OldCookies = window.Cookies; var api = window.Cookies = factory(); api.noConflict = function () &#123; window.Cookies = OldCookies; return api; &#125;; &#125; &#125;(function () &#123; // 对象拼接方法 function extend () &#123; var i = 0; var result = &#123;&#125;; for (; i &lt; arguments.length; i++) &#123; var attributes = arguments[ i ]; for (var key in attributes) &#123; result[key] = attributes[key]; &#125; &#125; return result; &#125; function init (converter) &#123; function api (key, value, attributes) &#123; var result; if (typeof document === 'undefined') &#123; return; &#125; // Write 当参数大于 1 的时候认为是 write 操作 if (arguments.length &gt; 1) &#123; // 拼接参数及默认参数 attributes = extend(&#123; path: '/' &#125;, api.defaults, attributes); // 设置过期时间， attributes.expires 是一个数字，代表过期天数 if (typeof attributes.expires === 'number') &#123; var expires = new Date(); // 获取当前时间，在加上 attributes.expires 的天数 864e+5 是一天的毫秒数 expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5); attributes.expires = expires; &#125; // We're using \"expires\" because \"max-age\" is not supported by IE，IE不支持 max-age，所以使用 expires 来设置过期时间 attributes.expires = attributes.expires ? attributes.expires.toUTCString() : ''; try &#123; result = JSON.stringify(value); // 如果是对象或者数组，转为 JSON if (/^[\\&#123;\\[]/.test(result)) &#123; value = result; &#125; &#125; catch (e) &#123;&#125; if (!converter.write) &#123; // 对 value 值进行了 encode 同时对其中部分 code 做了 decode 注意 replace 方法用的很高级 value = encodeURIComponent(String(value)) .replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent); &#125; else &#123; value = converter.write(value, key); &#125; // 对 key 值做了处理 key = encodeURIComponent(String(key)); key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent); key = key.replace(/[\\(\\)]/g, escape); var stringifiedAttributes = ''; // 将传入的 attributes 连接起来 domain=.geekang.org; expries=121314212; http for (var attributeName in attributes) &#123; if (!attributes[attributeName]) &#123; continue; &#125; stringifiedAttributes += '; ' + attributeName; if (attributes[attributeName] === true) &#123; continue; &#125; stringifiedAttributes += '=' + attributes[attributeName]; &#125; // 写入 cookie。这里说明 cookie 写入的方式 key=value; domain=.geekbang.org... console.log(key + '=' + value + stringifiedAttributes) return (document.cookie = key + '=' + value + stringifiedAttributes); &#125; // Read if (!key) &#123; result = &#123;&#125;; &#125; // To prevent the for loop in the first place assign an empty array // in case there are no cookies at all. Also prevents odd result when // calling \"get()\" var cookies = document.cookie ? document.cookie.split('; ') : []; var rdecode = /(%[0-9A-Z]&#123;2&#125;)+/g; var i = 0; for (; i &lt; cookies.length; i++) &#123; var parts = cookies[i].split('='); var cookie = parts.slice(1).join('='); if (!this.json &amp;&amp; cookie.charAt(0) === '\"') &#123; cookie = cookie.slice(1, -1); &#125; try &#123; var name = parts[0].replace(rdecode, decodeURIComponent); cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent); if (this.json) &#123; try &#123; cookie = JSON.parse(cookie); &#125; catch (e) &#123;&#125; &#125; if (key === name) &#123; result = cookie; break; &#125; if (!key) &#123; result[name] = cookie; &#125; &#125; catch (e) &#123;&#125; &#125; return result; &#125; api.set = api; api.get = function (key) &#123; return api.call(api, key); &#125;; api.getJSON = function () &#123; return api.apply(&#123; json: true &#125;, [].slice.call(arguments)); &#125;; api.defaults = &#123;&#125;; // remove 直接设置了传入的 key 的 value 位 ''，并且设置过期时间为负 api.remove = function (key, attributes) &#123; api(key, '', extend(attributes, &#123; expires: -1 &#125;)); &#125;; api.withConverter = init; return api; &#125; return init(function () &#123;&#125;); &#125;)); 结论如下： cookie 的读取方式为 document.cookie。获取到的是所有该域下 cookie key value 的字符串,不同 key value 之间以 ; 隔开。例如 text=1; name=newming; age=25。注意拿不到 expires path 等信息。然后可以通过字符串分割拿到某一个信息 cookie 的写入方式为 document.cookie = ‘key=value; expires=time; path=/; ‘。设置的时候为一条一条的设置，可以带上 path domain 等信息，属性之间同样以 ; 隔开，如果 value 是对象的活需要转为字符串 cookie 的删除 docoment.cookie = &#39;key=; path=/; expires=time&#39; 。注意时间为 UTCString，并且小于当前时间，即直接将某条属性设置过期即可删除","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"deep-compare","date":"2018-01-26T05:44:21.000Z","path":"2018/01/26/deep-compare/","text":"今天分享的是一个可以进行深度比较传入参数的方法。在日常的开发中，比较两个数据是否相等的情况非常多，对于基本数据类型的相对简单。但是当比较两个对象的时候就比较复杂了。下面分享一个在 stackoverflow 上看到的方法，可以比较传入的多个参数是否相等。 在阅读代码时加入了自己的一些注释，同时理了一下对比两个不知道数据类型的变量时，该如何去做。具体涉及到鉴别时各种条件的优先顺序以及需要注意的点。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 function deepCompare () &#123; var i, l, leftChain, rightChain; function compare2Objects (x, y) &#123; var p; // remember that NaN === NaN returns false // and isNaN(undefined) returns true // 第一步如果两个是 NaN 返回 true。要注意如何识别 NaN，即上边的两条注释 if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return true; &#125; // Compare primitives and functions. // Check if both arguments link to the same object. // Especially useful on the step where we compare prototypes // 第二步直接判断是否相等 if (x === y) &#123; return true; &#125; // Works in case when functions are created in constructor. // Comparing dates is a common scenario. Another built-ins? // We can even handle functions passed across iframes // 第三步，如果是函数或者是通过 new 出来的 String，它们的类型为 object ，调用他们的 toString 来检测 if ((typeof x === 'function' &amp;&amp; typeof y === 'function') || (x instanceof Date &amp;&amp; y instanceof Date) || (x instanceof RegExp &amp;&amp; y instanceof RegExp) || (x instanceof String &amp;&amp; y instanceof String) || (x instanceof Number &amp;&amp; y instanceof Number)) &#123; return x.toString() === y.toString(); &#125; // 第四步，到这里只剩下对象（包括&#123;&#125;, []，注意不包含 null，因为 null === null 为 true）没有判断出来 // At last checking prototypes as good as we can if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123; return false; &#125; /* var a = function fun () &#123;&#125; var b = new a a.prototype.isPrototypeOf(b) // true */ if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123; return false; &#125; if (x.constructor !== y.constructor) &#123; return false; &#125; if (x.prototype !== y.prototype) &#123; return false; &#125; // Check for infinitive linking loops if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123; return false; &#125; // Quick checking of one object being a subset of another. // todo: cache the structure of arguments[0] for performance // 这里只是检测了两个对象(数组)拥有相同的属性，并且属性类型相同，具体属性值还没有深度对比 for (p in y) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; &#125; for (p in x) &#123; // 首先反过来来了一遍上面（61-68）循环对比，避免 x 中包含的某个属性 y 中没有，不可以删除 if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; switch (typeof (x[p])) &#123; case 'object': case 'function': leftChain.push(x); rightChain.push(y); // 递归 if (!compare2Objects (x[p], y[p])) &#123; return false; &#125; leftChain.pop(); rightChain.pop(); break; default: if (x[p] !== y[p]) &#123; return false; &#125; break; &#125; &#125; return true; &#125; if (arguments.length &lt; 1) &#123; return true; //Die silently? Don't know how to handle such case, please help... // throw \"Need two or more arguments to compare\"; &#125; for (i = 1, l = arguments.length; i &lt; l; i++) &#123; leftChain = []; //Todo: this can be cached rightChain = []; if (!compare2Objects(arguments[0], arguments[i])) &#123; return false; &#125; &#125; return true; &#125;","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"mongoose 简易教程","date":"2018-01-02T13:22:12.000Z","path":"2018/01/02/mongoose/","text":"mongoose 是 nodejs 中连接应用与 mongodb 数据库的一个库。在 mongoose 中有几个重要的概念需要重点了解。 Schema: 数据库模板的描述、定义。以及数据库中的个字段的格式等定义。 Model: 数据库的模型，Schema 的具体实现。可以操作数据库。 Entity: 通过 Model 创建的具体的实例。也具有操作数据库的能力。 使用1 2 # 安装 npm install mongoose 启动数据库 1 mongod --dbpath=path 在 js 文件中使用编写代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 const mongoose = require('mongoose') mongoose.Promise = Promise // 让 mongoose 中的 Promise 使用 node 中全局的 Promise，也可以使用其他库，例如 bluebird，http://mongoosejs.com/docs/promises.html mongoose.set('debug', true) // 开启 debug mongoose.connect('mongodb://localhost/test') // 连接数据库 test 为数据库名称，默认端口为 27017，如果不是这个端口需要增加端口 mongoose.connection.on('open', () =&gt; &#123; console.log('mongodb opened') &#125;) // 创建 一个 User Schema，用来描述 User 集合的结构 const UserSchema = new mongoose.Schema(&#123; name: String, times: &#123; type: Number, default: 0 &#125; &#125;) // 创建 model const User = mongoose.model('User', UserSchema) // 基于 UserSchema 建模，这时会在数据库中自动创建 users 的集合，注意这里的大写的 User 会在数据库中转小写负数 // 创建具体的用户实例 ;(async () =&gt; &#123; // console.log(await User.find(&#123;&#125;).exec()) // [] // 实例化一个具体的用户 const user = new User(&#123; name: 'newming' &#125;) // 保存到数据库中 await user.save() // console.log(await User.find(&#123;&#125;).exec()) // [&#123;name: 'nemwing', times: 0&#125;] json 格式的一条数据 // 查找一条数据，并更新 const user = await User.findOne(&#123;name: 'newming'&#125;) user.name = 'newminghaha' await user.save() // console.log(await User.find(&#123;&#125;).exec()) // [&#123;name: 'nemwinghaha', times: 0&#125;] // 调用 Schema 静态方法 console.log(User.getUser('newminghaha').exec()) // 调用实例 method const user = await User.findOne(&#123;name: 'newminghaha'&#125;) const newUser = user.fetchUser('newminghaha') console.log(newUser) &#125;)() // 定义 Schema 前置钩子方法 http://mongoosejs.com/docs/api.html#schema_Schema-pre UserSchema.pre('save', next =&gt; &#123; this.times ++ next() // 每次保存前执行 &#125;) // 定义 Schema 静态方法 http://mongoosejs.com/docs/api.html#schema_Schema-static UserSchema.statics = &#123; async getUser(name) &#123; const user = await this.findOne(&#123; name &#125;) return user &#125; &#125; // 定义 Schema 实例方法 UserSchema.methods = &#123; async fetchUser(name) &#123; const user = await this.model('User').findOne(&#123; name: name &#125;).exec() &#125; &#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://newming.github.io/tags/mongodb/"}]},{"title":"mongodb 数据库","date":"2018-01-02T03:33:34.000Z","path":"2018/01/02/mongodb/","text":"在搞 node 后台开发过程中，肯定涉及到数据库的使用，其中个人使用最多就是 mongodb 数据库了。本文主要介绍 mongodb 的一些基本概念及使用。 1. 什么是MongoDB MongoDB是一个基于分布式文件存储的开源数据库系统 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 2. MongoDB安装2.1 windows安装Windows官方安装指南 2.2 mac安装Mac官方安装指南 先安装homebrew brew 使用brew安装mongodb 1 brew install mongodb 再安装可视化工具 Robomongo 3. mongodb启动与连接3.1 windows启动服务器端1 mongod --dbpath=./data 如果出现waiting for connections on port 27017就表示启动成功,已经在27017端口上监听了客户端的请求 注意：--dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经存在，否则服务开启失败 注意：这个命令窗体绝对不能关,关闭这个窗口就相当于停止了mongodb服务 也可以在命令后面加上参数 --port 27017 来指定端口 3.2 启动客户端连接服务器命令窗体中输入 mongo –host=127.0.0.1 或者 mongo 按回车键 备注：–host后的值表示服务器的ip地址 4. MongoDB基本概念 数据库 MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例 集合 数据库是由集合组成的,一个集合用来表示一个实体,如学生集合 文档 集合是由文档组成的，一个文档表示一条记录,比如一位同学张三就是一个文档 5. 数据库操作5.1 使用数据库语法 1 use database_name database_name代表数据库的名字 注：如果此数据库存在，则切换到此数据库下,如果此数据库还不存在也可以切过来 实例 切换到 person数据库下 5.2 查看所有数据库语法 1 show dbs 备注: 我们刚创建的数据库person 如果不在列表内， 要显示它，我们需要向 person 数据库插入一些数据 db.person.insert({name:”zhangSan”,age:30}) 5.3 查看当前使用的数据库语法 1 db 或 db.getName() 注：db代表的是当前数据库 也就是person这个数据库 实例 5.4 删除数据库语法 1 db.dropDatabase() 实例 6. 集合操作6.1 查看帮助语法 1 db.worker.help() 实例 6.2 查看数据库下的集合语法 1 show collections 实例 6.3 创建集合创建一个空集合 1 db.createCollection(collection_Name) collection_Name集合的名称 创建集合并插入一个文档 collection_Name集合的名称 document要插入的文档 1 db.collection_Name.insert(document) 7. 插入文档7.1 insert语法 1 2 db.collection_name.insert(document) ` 参数 collection_name 集合的名字 document 插入的文档 实例 每当插入一条新文档的时候mongodb会自动为此文档生成一个_id属性,_id一定是唯一的，用来唯一标识一个文档 _id也可以直接指定，但如果数据库中此集合下已经有此_id的话插入会失败 7.2 save语法 1 db.collection_name.save(document) 参数 collection_name 集合的名字 document 插入的文档 注：如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。 实例 1 db.person.save(&#123;name:&quot;xiaoHong&quot;,age:50&#125;) 1 db.person.save(&#123;_id:ObjectId(&quot;562c9caf671c978b6596e825&quot;),name:&quot;xiaoHong&quot;,age:10&#125;) 8. 更新文档语法 1 2 3 4 5 6 7 8 db.collection.update( &lt;query&gt;, &lt;updateObj&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt; &#125; ) 参数说明 query 查询条件,指定要更新符合哪些条件的文档 update 更新后的对象或指定一些更新的操作符 $set直接指定更新后的值 $inc在原基础上累加 upsert 可选，这个参数的意思是，如果不存在符合条件的记录时是否插入updateObj. 默认是false,不插入。 multi 可选，mongodb 默认只更新找到的第一条记录，如果这个参数为true,就更新所有符合条件的记录。 实例 将document数据中name是liSi 的数据的name修改为liSi_update 1 db.worker.update(&#123;name:&apos;liSi&apos;&#125;,&#123;$set:&#123;name:&apos;liSi_update&apos;&#125;&#125;) 注：如果有多条name是liSi的数据只更新一条,如果想全部更新需要指定{multi:true}的参数 9. 文档的删除remove方法是用来移除集合中的数据 语法 1 2 3 4 5 6 db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt; &#125; ) 参数说明 query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除匹配到的多个文档中的第一个 实例 删除worker集合里name是fJianZhou的所有Document数据 1 db.worker.remove(&#123;name:&apos;fJianZhou&apos;&#125;) 删除person集合里name是xiaoHong的第一条数据 1 db.person.remove(&#123;name:&quot;xiaoHong&quot;&#125;,1) 10. 查询文档10.1 find语法 1 db.collection_name.find() 参数 collection_name 集合的名字 实例 查询worker下所有的文档 1 db.worker.find() 10.2 查询指定列语法 1 db.collection_name.find(&#123;queryWhere&#125;,&#123;key:1,key:1&#125;) 参数列表 collection_name 集合的名字 queryWhere 参阅查询条件操作符 key 指定要返回的列 1 表示要显示 实例 1 db.worker.find(&#123;&#125;,&#123;age:1&#125;) 查询指定列 10.3 findOne查询匹配结果的第一条数据 语法 1 db.collection_name.findOne() 实例 1 db.worker.findOne() 11. 条件操作符条件操作符用于比较两个表达式并从mongoDB集合中获取数据 11.1 大于操作符语法 1 db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例 1 db.worker.find(&#123;age:&#123;$gt:30&#125;&#125;) 查询age 大于 30的数据 11.2 大于等于操作符语法1 db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例1 db.worker.find(&#123;age: &#123;$gte: 30&#125;&#125;) 查询age 3大于等于30 的数据 11.3 小于操作符语法1 db.collectoin_name.find( &#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;) 参数 collectoin_name集合名称 key 字段 value 值 实例1 db.worker.find(&#123;age: &#123;$lt: 30&#125;&#125;) 查询age 小于30的数据 11.4 小于等于操作符语法1 db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;) 参数 collectoin_name集合名词 key字段 value值 实例1 db.worker.find(&#123;age: &#123;$lte: 30&#125;&#125;) 查询age 小于等于30的数据 11.5 同时使用 $gte和$lte语法1 db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;,&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例查询age 大于等于 30 并且 age 小于等于 50 的数据1 db.worker.find(&#123;age: &#123;$gte: 30, $lte: 50&#125;&#125;) 11.6 等于语法1 db.collectoin_name.find(&#123;&lt;key&gt;:&lt;value&gt;,&lt;key&gt;:&lt;value&gt;&#125;) 参数 collectoin_name集合名词 key字段 value值 实例查询age = 30的数据1 db.worker.find(&#123;&quot;age&quot;: 30&#125;)` 11.7 使用 _id进行查询语法1 db.collectoin_name.find(&#123;&quot;_id&quot; : ObjectId(&quot;value&quot;)&#125;) 参数 value _id的值 实例查询_id是 562af23062d5a57609133974 数据1 db.worker.find(&#123;&quot;_id&quot; : ObjectId(&quot;562af23062d5a57609133974&quot;)&#125;) 11.8 查询结果集的条数语法1 db.collectoin_name.find().count() 参数 collectoin_name 集合名称 实例1 db.worker.find().count() 11.9 正则匹配语法1 db.collection.find(&#123;key:/value/&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例查询name里包含zhang的数据1 db.worker.find(&#123;name:/value/&#125;) 查询某个字段的值当中是否以另一个值开头1 db.worker.find(&#123;name:/^zhang/&#125;) 12. 与和或12.1 andfind方法可以传入多个键(key)，每个键(key)以逗号隔开 语法1 db.collection_name.find(&#123;key1:value1, key2:value2&#125;) 实例查询name是zhangRenYang并且age是30的数据1 db.worker.find(&#123;name:&apos;zhangRenYang&apos;,age:30&#125;) 12.2 or语法1 2 3 4 5 6 7 db.collection_name.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125; ) 实例查询age = 30 或者 age = 50 的数据1 db.worker.find(&#123;$or:[&#123;age = 30&#125;,&#123;age = 50&#125;]&#125;) 12.3 and和or联用语法1 2 3 4 5 6 7 8 9 10 db.collection_name.find( &#123; key1:value1, key2:value2, $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125; ) 实例查询 name是zhangRenYang 并且 age是30 或者 age是 50 的数据1 db.worker.find(&#123;name:&apos;zhangRenYang&apos;,$or:[&#123;age:30&#125;,&#123;age:50&#125;]&#125;) 13. 分页查询13.1 limit读取指定数量的数据记录语法1 db.collectoin_name.find().limit(number) 参数 collectoin_name集合 number读取的条数 实例查询前3条数据1 db.worker.find().limit(3) 13.2 skip跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数语法1 db.collectoin_name.find().skip(number) 参数 collectoin_name集合 number跳过的条数 实例查询3条以后的数据1 db.worker.find().skip(3) 13.3 skip+limit通常用这种方式来实现分页功能语法1 db.collectoin_name.find().skip(skipNum).limit(limitNum) 参数 collectoin_name 集合名称 skipNum 跳过的条数 limitNum 限制返回的条数 实例查询在4-6之间的数据1 db.worker.find().sort(&#123;age:-1&#125;) 13.4 sort排序sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。语法1 2 db.collectoin_name.find().sort(&#123;key:1&#125;) db.collectoin_name.find().sort(&#123;key:-1&#125;) 参数 collectoin_name集合 key表示字段 实例查询出并升序排序 {age:1} age表示按那个字段排序 1表示升序1 db.worker.find().sort(&#123;age:1&#125;)","tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://newming.github.io/tags/mongodb/"}]},{"title":"tail 命令","date":"2017-12-27T03:05:01.000Z","path":"2017/12/27/tail/","text":"用途:从指定点开始将文件写到标准输出。使用tail命令的-f选项可以方便的查阅正在改变的日志文件，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不但刷新，使你看到最新的文件内容。 tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。 Number 变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。如果值的前面有 +（加号），从文件开头指定的单元数开始将文件写到标准输出。如果值的前面有 -（减号），则从文件末尾指定的单元数开始将文件写到标准输出。如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。 Number 变量用于确定计数的起点的单元类型由 -b、-c、-k、-m 以及 -n 标志确定。如果没有指定其中的任何一个标志，那么 tail 命令就会读取指定文件的最后十行，并将其写到标准输出。这与在命令行输入 -n 10 是相同的。 1 2 tail -h # tail [-F | -f | -r] [-q] [-b # | -c # | -n #] [file ...] 命令参数 -f: 循环读取 -q: 不现实处理信息 -v: 显示详细的处理信息 -c [number]: 显示的字节数 -n [number]: 显示的行数 -b [Number]: 从 Number 变量表示的 512 字节块位置开始读取指定文件 -r: 从文件末尾以逆序方式显示输出。-r 标志的缺省值是以逆序方式打印整个文件。如果文件大于 20,480 字节，那么 -r 标志只显示最后的 20,480 字节。-r 标志只有与 -n 标志一起时才有效。否则，就会将其忽略。而且 -r 在 -n 前 1 2 3 4 5 6 7 8 # 显示 notes 文件的最后十行 tail notes # 要从第 200 字节开始，每次显示一页 notes 文件 tail -c +200 notes | pg # 跟踪文件变化，显示的是accounts最后十行，并持续监听 tail -f accounts","tags":[{"name":"shell","slug":"shell","permalink":"https://newming.github.io/tags/shell/"}]},{"title":"dom 知识汇总","date":"2017-12-26T11:55:59.000Z","path":"2017/12/26/dom-model/","text":"DOM: Document object model 文档对象模型，描述整个html页面中节点关系的谱图。熟练操作 DOM 在我们的日常开发中非常重要。 js DOM元素获取的方法(8种)document.getElementById(‘id’)通过id获取元素，如果id重复了，获取到的是第一个，区分大小写（在 IE 6,7中不区分） 在 IE 6,7 中会把元素的 name 当作 id 来使用 如果没有获取到则返回 null,可以用id直接代表这个对象，而不去提前获取。上下文只能是 document1 2 3 4 // html &lt;p id='test'&gt;js中可以直接通过id拿到我&lt;/p&gt; // js console.log(test); context.getElementsByTagName(‘li’)通过元素的标签名获取一组元素，有几个获取几个。可以根据上下文(context)获取我们获取元素的范围。 1 2 document.getElementsByTagName('li'); oDIv.getElementsByTagName('li'); document.getElementsByName(‘text’)通过元素的name属性获取一组元素 注意在 IE浏览器下只对表单元素起作用。这个方法常用于获取具有相同name的表单元素 context.getElementsByClassName(‘class’)在 IE 6~8 会报错 document.documentElement,document.body分别获取 html,body 元素，通常用来获取文档属性 1 var winW = document.documentElement.clientWidth || document.body.clientWidth // 兼容所有的浏览器获取当前浏览器宽度 document.querySelector,document.querySelectorAll在移动端常用的方法，IE6～8不支持。同时不存在映射关系 前者只获取一个元素，后者获取全部 1 2 3 4 5 document.querySelector('#id') document.querySelector('.class') document.querySelector('li') document.querySelectorAll('#id li') // 后代选择器 document.querySelectorAll(\"input[type='text']\") // 属性选择器 DOM 中的节点和关系属性w3chool的文档 获取关系的属性节点：node 一个html页面中的元素标签、文本、注释。。。都是节点。在标准浏览器下，空格和Enter（回车）都是文本节点1 2 3 4 5 6 7 oBox.childNodes // 获取所有的子节点 oBox.children // 获取所有的元素子节点 oBox.parentNode // 获取元素的父亲节点 oBox.previousSibling // 获取元素位于相同节点树层级的前一个元素，注意空格回车文本节点也会获取。(哥哥) oBox.nextSibling // 获取元素位于相同节点树层级的后一个元素。(弟弟) oBox.firstChild // 获取第一个子元素 oBox.lastChild // 获取元素的最后一个 节点主要的节点类型及其属性。 节点类型 nodeType nodeName nodeValue 元素节点（元素标签） 1 大写的标签名 null 文本节点（文字） 3 #text 文字内容 注释节点 8 #comment 注释内容 document 9 #document null 小案例，模拟children方法模拟children方法，实现获取指定元素下所有的元素子节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 1. 获取 children 标签元素 可以设置筛选 function getChildren(ele,tagName) &#123; var ary = []; var nodes = ele.childNodes; // 拿到元素下所有的子节点 for (var i = 0; i &lt; nodes.length; i++) &#123; var cur = nodes[i]; if (cur.nodeType===1) &#123; if (tagName) &#123; // 如果传了tagName，再次筛选 if (cur.nodeName.toLowerCase() === tagName.toLowerCase()) &#123; // 注意nodeName是大写，但是传入的参数不确定，所有先都转为小写 ary.push(cur) &#125; &#125;else &#123; // 如果没传tagName，默认将所有的子元素节点返回 ary.push(cur) &#125; &#125; &#125; return ary; &#125; let box = document.getElementById('box'); getChildren(document.getElementById(box, 'p')) // 2. 获取 children 标签元素 可以设置筛选，根据兼容处理 function childern (curEle, tagName) &#123; var ary = [] if (/MSIE (6|7|8)/i.test(navigator.userAgent)) &#123; var nodes = ele.childNodes; for (var i = 0; i &lt; nodes.length; i++) &#123; var cur = nodes[i]; if (cur.nodeType === 1) &#123; ary.push(cur) &#125; &#125; nodes = null &#125; else &#123; ary = Array.prototype.slice.call(curEle.children) &#125; if (typeof tagName === 'string') &#123; for (var k = 0; k &lt; ary.length; k++) &#123; var curEle = ary[k] if (curEle.nodeName.toLowerCase() !== tagName.toLowerCase()) &#123; ary.splice(k, 1) k-- &#125; &#125; &#125; return ary &#125; 小案例，获取siblingshtml 结构 1 2 3 4 5 6 7 8 9 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;!-- 我是注释 --&gt; &lt;li id='li3'&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;!-- 如何通过js获取到3的上一个兄弟2 --&gt; &lt;!-- 需要注意原生的 DOM 属性 previousSibling 会计算空格和回车还有注释等，所以往上找多少级不确定 --&gt; js 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // 1.获取上一个兄弟节点，兼容IE var li3 = document.getElementById('li3') function prev(ele) &#123; var pre = ele.previousSibling; while (pre &amp;&amp; pre.nodeType !== 1) &#123; pre = pre.previousSibling; &#125; return pre &#125; prev(li3) // 2. 获取上一个兄弟节点，previousElementSibling 标准浏览器 // 3.获取所有的上级兄弟节点 var li3 = document.getElementById('li3') function prevAll(ele) &#123; var ary = []; var pre = ele.previousSibling; while (pre) &#123; if (pre.nodeType === 1) &#123; ary.unshift(pre) &#125; pre = pre.previousSibling; &#125; return ary &#125; prevAll(li3) // 4. 获取当前元素的索引 function index(curEle) &#123; // 有几个哥哥就是几 var ary = []; var pre = curEle.previousElementSibling; while (pre) &#123; ary.unshift(pre) pre = pre.previousElementSibling; &#125; return ary.length &#125; // 5. firstchild 第一个元素节点 function firstChild (parentNode) &#123; return parentNode.children[0] ? parentNode.children[0] : null &#125; DOM 增删改 document.createElement(‘div’); 动态创建一个标签元素 box.appendChild() 将元素添加到指定的容器中的末尾 insertBefore(newItem,existingItem) 把新的元素插入到老得元素之前，如果老元素不存在，会放到末尾 removeChild(item) 删除元素 cloneNode(true || false) 克隆元素默认false只克隆当前元素，true clone 子孙 replaceChild(newnode,oldnode) document.createDocumentFragment() 创建文档碎片 属性的增删改查 setAttribute() getAttribute() removeAttribute() 在IE 6~8 中不能修改class属性 box.className可以 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 1. append function append (newEle, container) &#123; container.appendChild(newEle) &#125; // 2. prepend function prepend (newEle, container) &#123; var firstChild = container.children[0] ? parentNode.children[0] : null container.insertBefore(newEle, firstChild) &#125; // 3. insertBefore function insertBefore (newEle, oldEle) &#123; oldEle.parentNode.insertBefore(newEle, oldEle) &#125; // 4. insertAfter function insertAfter (newEle, oldEle) &#123; oldEle.parentNode.insertBefore(newEle, oldEle.nextElementSibling) &#125; dom 数据绑定方法1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 1. 通过 document.createElement 进行创建插入，会造成多次 dom 回流，即重新渲染 dom，造成性能浪费，不影响原有的 dom document.createElement document.appendChild // 2. 字符串拼接，只需要一次回流，但是会造成原有的 dom 丢失事件绑定 var str = '&lt;span&gt;aa&lt;/span&gt;' box.innerHTML = str // 3. 文档碎片 var frg = document.createDocumentFragment() // 创建一个文档碎片相当于临时创建了一个容器 for (var i = 0; i &lt; 5; i++) &#123; var oLi = document.createElement('li') oLi.innerHTML = i frg.appendChild(oLi) &#125; oUl.appendChild(frg) // 优点:不影响原有 li，一次回流 frg = null 操作元素 class 属性1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 1. hasClass 是否包含某个class，可以直接用 dom.classList.contains function hasClass (curEle, className) &#123; var reg = new RegExp('(^|\\\\s)' + className + '(\\\\s|$)') // var reg = new RegExp('(^| +)' + className + '( +|$)') return reg.test(curEle.className) &#125; // 2. addClass支持传多个class，以空格隔开，可以直接用 dom.classList.add(class,class,...)，不过存在兼容问题 function addClass(curEle, className) &#123; var ary = className.replace(/(^ +| +$)/g, '').split(/ +/g) // split(' ') for (var i = 0; i &lt; ary.length; i++) &#123; var curClass = ary[i] if (!hasClass(curEle, curClass)) &#123; curEle.className += ' ' + curClass &#125; &#125; &#125; // 3. removeClass，支持传多个class，以空格隔开，可以直接用 dom.classList.remove(class, class, ...)，不过存在兼容问题 function removeClass(curEle, className) &#123; var ary = className.replace(/(^ +| +$)/g, '').split(/ +/g) for (var i = 0; i &lt; ary.length; i++) &#123; var curClass = ary[i] if (hasClass(curEle, curClass)) &#123; var reg = new RegExp('(^| +)' + curClass + '( +|$)', 'g') curEle.className = curEle.className.replace(reg, ' ').trim() &#125; &#125; &#125; getElementsByClassName 的兼容处理1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // className: 要获取的元素的样式类名，可能一个也可能多个，多个之间用空格（几个都行）隔开 // context: 获取元素的上下文，不传的话默认为 document function getElementsByClass (className, context) &#123; context = context || document var classNameAry = className.replace(/(^ +| +$)/g, '').split(/ +/g) // 获取上下文包含的所有标签 var nodeList = context.getElementsByTagName('*') var ary = [] for (var i = 0; i &lt; nodeList.length; i++) &#123; var curNode = nodeList[i] var flag = true for (var k = 0; k &lt; classNameAry.length; k++) &#123; var reg = new RegExp('(^| +)' + classNameAry[k] + '( +|$)') if (!reg.test(curNode.className)) &#123; flag = false break &#125; &#125; if (flag) &#123; ary.push(curNode) &#125; &#125; &#125; 操作浏览器属性1 2 3 4 5 6 7 8 9 // 两个参数，只传一个是获取，两个是设置 function win (attr, val) &#123; if (typeof val === 'undefined') &#123; return document.documentElement[attr] || document.body[attr] &#125; else &#123; document.documentElement[attr] = val document.body[attr] = val &#125; &#125; 获取元素样式属性值 元素.style.属性：样式必须写在行内样式(不常用) 通过 window 提供的一个方法 getComputedStyle 来获取所有经过浏览器计算过的（只要当前元素标签可以在页面中呈现出来，那么它的样式都是经过浏览器的计算／渲染过的，哪怕有些样式没有写，同样可以获取）样式属性。IE 6,7,8 不兼容 在 IE 6,7,8 下使用 currentStyle 来获取元素的样式属性，不支持伪类 box.currentStyle[attr] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 第一个参数是要获取的 dom 元素，第二个是伪类，一般不用，获取到的是当前元素的所有的样式 window.getComputedStyle('元素', '伪类')[attr] // 兼容，不同浏览器获取到的属性不一定相同，主要是 IE 的其他的问题 function getStyle (element, attr) &#123; let val = null if ('getComputedStyle' in window) &#123; val = window.getComputedStyle(element)[attr] &#125; else &#123; // IE 6,7,8 if (attr === 'opacity') &#123; val = element.currentStyle['filter'] // 将数字除以 100 为标准浏览器的 opacity let reg = /^alpha\\(opacity=(\\d+(?:\\.\\d+)?)\\)$/i // 第二次升级：匹配 0-100 的整数或小数，将第一个分组捕获，?: 只匹配不捕获 val = reg.test(val) ? reg.exec(val)[1] / 100 : 1 &#125; else &#123; val = element.currentStyle[attr] &#125; &#125; let reg = /^(-?\\d+(\\.\\d+)?)(px|pt|rem|em)?$/i // 第一次升级：去掉数值单位，数字开头px,pt等单位结尾的单个数值 return reg.test(val) ? parseFloat(val) : val &#125; getStyle(box, 'width') // 需要去掉单位的功能 getStyle(box, 'opacity') // IE 6-8 不设置这个属性，设置的是 filter: alpha(opacity=10) 修改 dom 样式在 js 中给元素设置样式属性值，我们只能通过 dom.style[attr] = value 这种方式给当前元素设置行内样式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 1. 单个样式设置。某些传递进来的值没有单位，把默认单位补上 function setCss (curEle, attr, value) &#123; // 兼容 float 样式值 if (attr === 'float') &#123; curEle['style']['cssFloat'] = value curEle['style']['styleFloat'] = value return &#125; // 兼容 opacity if (attr === 'opacity') &#123; curEle['style'][attr] = value curEle['style']['filter'] = 'alpha(opacity=' + value * 100 + ')' return &#125; var reg = /^(width|height|top|bottom|left|right|((margin|padding)(Top|Bottom|Left|Right)?))$/ if (reg.test(attr)) &#123; if (!isNaN(value)) &#123; value += 'px' &#125; &#125; curEle['style'][attr] = value &#125; // 2. 批量设置样式 function setGroupCss (curEle, options) &#123; options = options || 0 // 防止没传值的时候调用 toString 方法出错 // 检测 options 的数据类型 if (options.toString() !== '[object Object]') &#123; return &#125; for (var key in options) &#123; if (options.hasOwnProperty(key)) &#123; this.setCss(curEle, key, options[key]) &#125; &#125; &#125; // 3. 模拟 jquery 中的 css 方法。实现获取，单独设置，批量设置元素的样式 function css (curEle) &#123; var argTwo = arguments[1] var ary = Array.prototype.slice.call(arguments, 1) if (typeof argTwo === 'string') &#123; var argThree = arguments[2] if (typeof argThree === 'undefined') &#123; // 第三个参数可能是数字 0，所以这里必须是 undefined return getStyle(curEle, argTwo) &#125; setCss.apply(curEle, ary) // this.setCss(curEle, argTwo, argThree) return &#125; // 设置多个样式 argTwo = argTwo || 0 if (argTwo.toString() === '[object Object]') &#123; setGroupCss.apply(curEle, ary) &#125; &#125;","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"网站升级 HTTPS","date":"2017-12-23T10:03:26.000Z","path":"2017/12/23/enable-mysite-https/","text":"哈哈，从今天开始，我的网站正式升级 https，从此不在被可恶的运营商注入广告了。这里主要记录一下繁琐的升级过程。 首先要感谢耗子哥的文章以及免费的 https 证书提供机构let’s Encrypt，当然还有很多其他文章的指导。 目前我关注的网站主要是两个，一个是放到自己服务器上的主站，另一个是托管到 github 的博客，由于博客是托管到 github 的，当时为了访问方便，做了 CNAME，绑定到了 newming.cn 上，而绑定方案是通过 dns 服务商处将 newming.cn 的记录直接指向了我的 github 博客的 ip，所以，如果要给博客升级 https 就不能在这么做了。 第一步: 反向代理 gh-pages参考文章 第一步要做的就是将我的 dns 配置中以前指向 GitHub 的两条记录停掉，转而指向我的服务器。 第二布就是在我的服务器上去增加 newming.cn 这个域名的配置了，具体代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 server &#123; listen 80; server_name newming.cn; location / &#123; proxy_pass https://newming.github.io; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; &#125; 配置完成之后直接 sudo nginx -s reload 重启即可 第二步: 部署 https参考文章 这里直接按文章步骤执行即可，其中在执行 sudo certbot --nginx 有些需要可选项可以根据自己情况选择，比如是否强制跳转 https，这里我选择的是，当然你也可以在之后自行修改 nginx 配置文件。 第三步: 升级 nginx因为开启 http2需要高版本的 nginx，所以就做了一个 nginx 升级，如果你的配置文件较为重要，请提前备份，这里我备份了 /etc/nginx/nginx.conf 文件，不过后来发现，再升级的时候 nginx 会自动给我备份出来一个 /etc/nginx/nginx.conf.dpkg-old 文件。升级中同样会有一些选择，其中有一个是否使用最新的配置文件，这里我选了是，之后一路平坦。 1 2 3 sudo add-apt-repository ppa:nginx/stable sudo apt-get update sudo apt-get install nginx 至此，折腾完毕，整整一下午过去了。生命不止，折腾不止。","tags":[{"name":"nginx","slug":"nginx","permalink":"https://newming.github.io/tags/nginx/"}]},{"title":"position sticky 属性","date":"2017-12-19T06:02:30.000Z","path":"2017/12/19/position-sticky/","text":"今天带来的是一个逆天的 css 属性，position: sticky。粘性定位。 相信大家对 css 中 position 属性的用法不陌生，那么今天这个属性是做什么的呢？他就是用来做吸顶的效果的，不需要 js 计算，只需要两条 css 属性即可。 请看下方效果，标题 A,C,E,T等自动吸顶。 See the Pen 粘性定位 by newming (@newming) on CodePen. 其中核心代码就只有两句 css。其中 top 为吸顶效果的边界值。我们可以想像成加了 sticky 属性后，这个元素会自动去按照我们的给定的边界值计算，具体表现为什么。具体来说就是按照 position: fixed; 来算。比如例子中，当标题 fixed 后，它当前的位置的值如果比我们给定的 -1px 小，就表现为 fixed 的效果，如果大于 -1px，表现为 relative 效果 1 2 position: sticky; top: -1px; 综上，sticky 会变现出两种其他 position 效果，当小于边界值，为 fixed，反之则 relative。有个蛋疼的地方是： android 表现不佳。","tags":[{"name":"css","slug":"css","permalink":"https://newming.github.io/tags/css/"}]},{"title":"自定义 range input 样式","date":"2017-12-15T04:44:02.000Z","path":"2017/12/15/custom-range-style/","text":"最近由于业务需求需要做一个控制音量的滑块按钮组件，由于 js 实现起来比较复杂，需要考虑 touch 和 click 之间的切换。所以决定使用 h5 新增的 input range 来实现，只要改掉其默认样式就好。 几番搜索之后找到了 css tricks 的一篇文章，非常不错，所以再此简单记录顺带翻译(-_^)一下。（准不准确不好说） 首先统一一下说法，range input 有两部分，可以拖动的叫滑块(thumb)，底部的是 track 第一步：去掉默认样式需要根据浏览器需要处理他们不同的默认样式，这里需要覆盖好几条样式属性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 input[type=range] &#123; -webkit-appearance: none; /* 去掉底部的 track 默认样式，就是整个灰条 */ width: 100%; /* Firefox 需要指定明确的宽度 */ background: transparent; /* 否则在 Chrome 中是白色背景 */ &#125; /* 去掉 webkit 内核 滑块 的样式 */ input[type=range]::-webkit-slider-thumb &#123; -webkit-appearance: none; &#125; input[type=range]:focus &#123; outline: none; /* 去除获取焦点时蓝色的外边框，你也可以自己定制其他你想要的效果 */ &#125; input[type=range]::-ms-track &#123; width: 100%; cursor: pointer; /* 这个是 IE 的 track 样式，没验证过 */ background: transparent; border-color: transparent; color: transparent; &#125; 到此我们已经有了一个兼容各浏览器的看不见的或者说没有样式的 range input。现在我们开始添加自定义的样式 第二步：给滑块增加样式你点击或者拖拽的那个小玩意叫做滑块（thumb），它就像一个普通的 HTML 元素一样可以被定义各种样式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* WebKit/Blink 样式定义 */ input[type=range]::-webkit-slider-thumb &#123; -webkit-appearance: none; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; margin-top: -14px; /* 在 Chrome 中你需要给定一个明确的 margin，但是在 Firefox 和 IE 中这个是固定的 */ box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; /* 添加一条炫酷的效果为你的 thumb */ &#125; /* Firefox 同上 */ input[type=range]::-moz-range-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; &#125; /* IE 同上 */ input[type=range]::-ms-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; &#125; 注意我们重复的写了很多代码，但这是必须的，你不能使用逗号去分割这几个选择器。浏览器会忽略全部的选择器如果逗号连接的部分中存在它不识别的。 现在我们的滑块是这个样子的: 第三步：给 track 添加样式thumb 所在的可滑动的那条线就是 track，它也像一个普通的 HTML 元素一样可以被定义各种样式。 在 IE 中需要注意：IE 10 以上有一些细微的不同表现。在 IE 中，你可以为 track 分别定义 thumb 左(lower)右(upper) 两边的样式。 另外需要注意的是你可以添加 track 的 focus 效果，当用户与 range input 进行交互的时候 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 input[type=range]::-webkit-slider-runnable-track &#123; width: 100%; height: 8.4px; cursor: pointer; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101; &#125; input[type=range]:focus::-webkit-slider-runnable-track &#123; background: #367ebd; &#125; input[type=range]::-moz-range-track &#123; width: 100%; height: 8.4px; cursor: pointer; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101; &#125; input[type=range]::-ms-track &#123; width: 100%; height: 8.4px; cursor: pointer; background: transparent; border-color: transparent; border-width: 16px 0; color: transparent; &#125; input[type=range]::-ms-fill-lower &#123; background: #2a6495; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; &#125; input[type=range]:focus::-ms-fill-lower &#123; background: #3071a9; &#125; input[type=range]::-ms-fill-upper &#123; background: #3071a9; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; &#125; input[type=range]:focus::-ms-fill-upper &#123; background: #367ebd; &#125; 现在你的 track 看起来是这样的： 最后：完整的 Range Input我们在上边已经创建了一个 thumb 和一个 track，我们可以将 css 进行合并。 完整的 css 如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 input[type=range] &#123; -webkit-appearance: none; margin: 18px 0; width: 100%; &#125; input[type=range]:focus &#123; outline: none; &#125; input[type=range]::-webkit-slider-runnable-track &#123; width: 100%; height: 8.4px; cursor: pointer; animate: 0.2s; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101; &#125; input[type=range]::-webkit-slider-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; -webkit-appearance: none; margin-top: -14px; &#125; input[type=range]:focus::-webkit-slider-runnable-track &#123; background: #367ebd; &#125; input[type=range]::-moz-range-track &#123; width: 100%; height: 8.4px; cursor: pointer; animate: 0.2s; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101; &#125; input[type=range]::-moz-range-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; &#125; input[type=range]::-ms-track &#123; width: 100%; height: 8.4px; cursor: pointer; animate: 0.2s; background: transparent; border-color: transparent; border-width: 16px 0; color: transparent; &#125; input[type=range]::-ms-fill-lower &#123; background: #2a6495; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; &#125; input[type=range]::-ms-fill-upper &#123; background: #3071a9; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; &#125; input[type=range]::-ms-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; &#125; input[type=range]:focus::-ms-fill-lower &#123; background: #3071a9; &#125; input[type=range]:focus::-ms-fill-upper &#123; background: #367ebd; &#125; 完整的效果如下： 更多内容请阅读 原文","tags":[{"name":"css","slug":"css","permalink":"https://newming.github.io/tags/css/"}]},{"title":"IT 必备词汇","date":"2017-11-03T02:10:29.000Z","path":"2017/11/03/words-for-it/","text":"This document will put some words in common usage serial 连续的（中间件的处理，one after another） parallel 平行的 exected 执行 faded 消失 reliable 可靠地 secure 安全的 offine mode 离线模式 deterministic 确定性 network performance 网络性能 queue up 排队 avoid 避免 upgrade 升级 continuous integration 持续集成 authority 权利，权限 authorise 授权，批准，委托 stability: 稳定性 standard: 标准的 constant: n常量 variable: n变量 dictionary: n字典 integer: n整数，整型 keyword n关键字 static: adj静态的 class: n 类 subclass: n 子类 superclass: n父类 polymorphism: n多态 inherit v继承 inheritance: n继承 interface: n接口 structure: n结构 instance: n 实例 property: n 属性 enumeration: n枚举 function: n 函数 parameter: n 参数 functionality: n功能 method: n 方法 element: n元素 call: v 调用 random: adj 随机的 generate: v产生，生成 generator: n生成器 implement: v实现 implementation: n实现 expression: n表达式 scope: n 范围 区域 initial: adj 最初的 initializer: n 初始化方法 initialization n初始化 deinitializer: n析构方法 item: n 项目; 条，条款; 一则 encapsulate: v封装 protocol: n 协议 delegate: v代理 delegation: n 代理 extend: v 拓展 extension: n拓展 external: adj 外部的 conform: v 遵守，遵照，遵循 iterate: v迭代 loop: n 循环 downcast: v向下转型 unwrap: v 拆箱 force-unwrap: v 强制拆箱 statement: n声明 optional: adj 可选的 code snippet: n 代码片段 define: v 定义 definition: n定义 contain: v 包含 query: v查询 particular: adj 特定的 type casting: 类型转换 cast: v 转换 operator: n 操作符 hierarchy: n 层次体系 subscript: n脚本 comma: n冒号 access: v访问，获取 exclamation mark: n感叹号 assign: v 赋值 assignment: n赋值 increase: v 增加 ，增大，增多 increasement: n 增加 ，增大，增多 decrease: v减少，减小 decreasement: v 减少，减小 global: adj 全局的 closure: n闭包 allocate: v分配 memory: n内存 reference: n引用 observe: v观察 observer: n观察者 modify: v修改 format: n格式 sort: v排序 nested: adj 嵌套的 reuse: v复用，重用 entity: n实体 public: adj 公共的，公开的 private: adj 私有的 internal: adj内部的 framework: n框架 unit test: 单元测试 associate: v关联 generic: n 范型 collection: n集合 swap: v交换 original: adj初始的 compile: v编译 characteristic: n性质 override: v重写，复写 overload: v重载 index: n索引 syntax: n语法","tags":[{"name":"English","slug":"English","permalink":"https://newming.github.io/tags/English/"}]},{"title":"数组排序算法","date":"2017-09-21T01:53:16.000Z","path":"2017/09/21/arrsort/","text":"简单实现3种数组排序 冒泡排序 快速排序 插入排序 冒泡排序1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 var arr = [12,10,13,8,4]; // target: [4,8,10,12,13] 从小到大排序 // 思想：当前项和后一项进行比较，如果当前项大于后一项，两者交换位置 /* 第一轮比较四次，将最大的已经放到最后了，接下来下一轮，一共需要arr.length-1轮 [10,12,13,8,4] [10,12,13,8,4] [10,12,8,13,4] [10,12,8,4,13] 接下来第二轮比较三次 i控制轮数，从0开始的话 i=0第一轮 比较arr.length-1-0次 i=1第一轮 比较arr.length-1-1次 i=2第一轮 比较arr.length-1-2次 ... i=n第n轮 比较arr.length-1-n次 当当前项大于后一下交换位置 var a = 12; var b = 13; var c = null; c = a; a = b; b = c */ function sortAry(ary)&#123; // i代表轮数，比较ary.length-1次 for (var i = 0; i &lt; ary.length-1; i++) &#123; // 比较arr.length-1-i次，j代表每一轮比较的次数,不用和自己比，不用和上一轮最后一项的最大值比较 for (var j = 0; j &lt; ary.length-1-i; j++) &#123; var cur = ary[j],next = ary[j+1]; if (cur&gt;next) &#123; // 如果当前项大于下一项，交换位置 var temp = null; temp = ary[j]; ary[j] = ary[j+1]; ary[j+1] = temp; &#125; &#125; &#125; &#125; sortAry(arr) console.log(arr); 快速排序从数组的中间拿一个值，然后通过这个值挨个和数组里面的值进行比较，如果大于的放一边，小于的放一边，然后把这些合并，再进行比较，如此反复即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 var arr = [3,1,4,2,5,21,6,15,63]; function sortA(arr)&#123; // 如果只有一位，就没有必要比较 if(arr.length&lt;=1)&#123; return arr; &#125; // 获取中间值的索引 var len = Math.floor(arr.length/2); // 截取中间值 var cur = arr.splice(len,1); // 小于中间值放这里面 var left = []; // 大于的放着里面 var right = []; for(var i=0;i&lt;arr.length;i++)&#123; // 判断是否大于 if(cur&gt;arr[i])&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; // 通过递归，上一轮比较好的数组合并，并且再次进行比较。 return sortA(left).concat(cur,sortA(right)); console.log(sortA(left).concat(cur,sortA(right));); &#125; console.log(sortA(arr)); 额，理解起来比较难，画了个图 插入排序(INSERTION-SORT)插入排序：对于少量元素比较有效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function sort(elements)&#123; //假设第0个元素是一个有序的数列，第1个以后的是无序的序列， //所以从第1个元素开始将无序数列的元素插入到有序数列中 for(var i = 1; i &lt; elements.length; i++)&#123; //升序 if(elements[i] &lt; elements[i-1])&#123; //取出无序数列中的第i个作为被插入元素 var guard = elements[i]; //记住有序数列的最后一个位置，并且将有序数列位置扩大一个 var j = i - 1; // elements[i] = elements[j]; // 我发现这句是多余的 //比大小，找到被插入元素所在的位置 while(j &gt;= 0 &amp;&amp; guard &lt; elements[j])&#123; elements[j+1] = elements[j]; j--; &#125; //插入 elements[j+1] = guard; &#125; &#125; &#125; var elements = [10, 9, 8, 7, 6, 5]; console.log('before: ' + elements); sort(elements); console.log(' after: ' + elements);","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"introduce","date":"2017-09-07T04:59:46.000Z","path":"2017/09/07/introduce/","text":"关于本博客介绍 随手记录工作中的一些经验新得，或者是一些其他的东西。内容可能会涉及前端(主要)，后端，数据库，nginx，网站，英语等等。","tags":[]}]