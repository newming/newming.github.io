[{"title":"deep-compare","date":"2018-01-26T05:44:21.000Z","path":"2018/01/26/deep-compare/","text":"今天分享的是一个可以进行深度比较传入参数的方法。在日常的开发中，比较两个数据是否相等的情况非常多，对于基本数据类型的相对简单。但是当比较两个对象的时候就比较复杂了。下面分享一个在 stackoverflow 上看到的方法，可以比较传入的多个参数是否相等。 在阅读代码时加入了自己的一些注释，同时理了一下对比两个不知道数据类型的变量时，该如何去做。具体涉及到鉴别时各种条件的优先顺序以及需要注意的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123function deepCompare () &#123; var i, l, leftChain, rightChain; function compare2Objects (x, y) &#123; var p; // remember that NaN === NaN returns false // and isNaN(undefined) returns true // 第一步如果两个是 NaN 返回 true。要注意如何识别 NaN，即上边的两条注释 if (isNaN(x) &amp;&amp; isNaN(y) &amp;&amp; typeof x === 'number' &amp;&amp; typeof y === 'number') &#123; return true; &#125; // Compare primitives and functions. // Check if both arguments link to the same object. // Especially useful on the step where we compare prototypes // 第二步直接判断是否相等 if (x === y) &#123; return true; &#125; // Works in case when functions are created in constructor. // Comparing dates is a common scenario. Another built-ins? // We can even handle functions passed across iframes // 第三步，如果是函数或者是通过 new 出来的 String，它们的类型为 object ，调用他们的 toString 来检测 if ((typeof x === 'function' &amp;&amp; typeof y === 'function') || (x instanceof Date &amp;&amp; y instanceof Date) || (x instanceof RegExp &amp;&amp; y instanceof RegExp) || (x instanceof String &amp;&amp; y instanceof String) || (x instanceof Number &amp;&amp; y instanceof Number)) &#123; return x.toString() === y.toString(); &#125; // 第四步，到这里只剩下对象（包括&#123;&#125;, []，注意不包含 null，因为 null === null 为 true）没有判断出来 // At last checking prototypes as good as we can if (!(x instanceof Object &amp;&amp; y instanceof Object)) &#123; return false; &#125; /* var a = function fun () &#123;&#125; var b = new a a.prototype.isPrototypeOf(b) // true */ if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) &#123; return false; &#125; if (x.constructor !== y.constructor) &#123; return false; &#125; if (x.prototype !== y.prototype) &#123; return false; &#125; // Check for infinitive linking loops if (leftChain.indexOf(x) &gt; -1 || rightChain.indexOf(y) &gt; -1) &#123; return false; &#125; // Quick checking of one object being a subset of another. // todo: cache the structure of arguments[0] for performance // 这里只是检测了两个对象(数组)拥有相同的属性，并且属性类型相同，具体属性值还没有深度对比 for (p in y) &#123; if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; &#125; for (p in x) &#123; // 首先反过来来了一遍上面（61-68）循环对比，避免 x 中包含的某个属性 y 中没有，不可以删除 if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) &#123; return false; &#125; else if (typeof y[p] !== typeof x[p]) &#123; return false; &#125; switch (typeof (x[p])) &#123; case 'object': case 'function': leftChain.push(x); rightChain.push(y); // 递归 if (!compare2Objects (x[p], y[p])) &#123; return false; &#125; leftChain.pop(); rightChain.pop(); break; default: if (x[p] !== y[p]) &#123; return false; &#125; break; &#125; &#125; return true; &#125; if (arguments.length &lt; 1) &#123; return true; //Die silently? Don't know how to handle such case, please help... // throw \"Need two or more arguments to compare\"; &#125; for (i = 1, l = arguments.length; i &lt; l; i++) &#123; leftChain = []; //Todo: this can be cached rightChain = []; if (!compare2Objects(arguments[0], arguments[i])) &#123; return false; &#125; &#125; return true;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"mongoose 简易教程","date":"2018-01-02T13:22:12.000Z","path":"2018/01/02/mongoose/","text":"mongoose 是 nodejs 中连接应用与 mongodb 数据库的一个库。在 mongoose 中有几个重要的概念需要重点了解。 Schema: 数据库模板的描述、定义。以及数据库中的个字段的格式等定义。 Model: 数据库的模型，Schema 的具体实现。可以操作数据库。 Entity: 通过 Model 创建的具体的实例。也具有操作数据库的能力。 使用12# 安装npm install mongoose 启动数据库 1mongod --dbpath=path 在 js 文件中使用编写代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const mongoose = require('mongoose')mongoose.Promise = Promise // 让 mongoose 中的 Promise 使用 node 中全局的 Promise，也可以使用其他库，例如 bluebird，http://mongoosejs.com/docs/promises.htmlmongoose.set('debug', true) // 开启 debugmongoose.connect('mongodb://localhost/test') // 连接数据库 test 为数据库名称，默认端口为 27017，如果不是这个端口需要增加端口mongoose.connection.on('open', () =&gt; &#123; console.log('mongodb opened')&#125;)// 创建 一个 User Schema，用来描述 User 集合的结构const UserSchema = new mongoose.Schema(&#123; name: String, times: &#123; type: Number, default: 0 &#125;&#125;)// 创建 modelconst User = mongoose.model('User', UserSchema) // 基于 UserSchema 建模，这时会在数据库中自动创建 users 的集合，注意这里的大写的 User 会在数据库中转小写负数// 创建具体的用户实例;(async () =&gt; &#123; // console.log(await User.find(&#123;&#125;).exec()) // [] // 实例化一个具体的用户 const user = new User(&#123; name: 'newming' &#125;) // 保存到数据库中 await user.save() // console.log(await User.find(&#123;&#125;).exec()) // [&#123;name: 'nemwing', times: 0&#125;] json 格式的一条数据 // 查找一条数据，并更新 const user = await User.findOne(&#123;name: 'newming'&#125;) user.name = 'newminghaha' await user.save() // console.log(await User.find(&#123;&#125;).exec()) // [&#123;name: 'nemwinghaha', times: 0&#125;] // 调用 Schema 静态方法 console.log(User.getUser('newminghaha').exec()) // 调用实例 method const user = await User.findOne(&#123;name: 'newminghaha'&#125;) const newUser = user.fetchUser('newminghaha') console.log(newUser)&#125;)()// 定义 Schema 前置钩子方法 http://mongoosejs.com/docs/api.html#schema_Schema-preUserSchema.pre('save', next =&gt; &#123; this.times ++ next() // 每次保存前执行&#125;)// 定义 Schema 静态方法 http://mongoosejs.com/docs/api.html#schema_Schema-staticUserSchema.statics = &#123; async getUser(name) &#123; const user = await this.findOne(&#123; name &#125;) return user &#125;&#125;// 定义 Schema 实例方法UserSchema.methods = &#123; async fetchUser(name) &#123; const user = await this.model('User').findOne(&#123; name: name &#125;).exec() &#125;&#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://newming.github.io/tags/mongodb/"}]},{"title":"mongodb 数据库","date":"2018-01-02T03:33:34.000Z","path":"2018/01/02/mongodb/","text":"在搞 node 后台开发过程中，肯定涉及到数据库的使用，其中个人使用最多就是 mongodb 数据库了。本文主要介绍 mongodb 的一些基本概念及使用。 1. 什么是MongoDB MongoDB是一个基于分布式文件存储的开源数据库系统 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 2. MongoDB安装2.1 windows安装Windows官方安装指南 2.2 mac安装Mac官方安装指南 先安装homebrew 1http://brew.sh/ 使用brew安装mongodb 1brew install mongodb 再安装可视化工具Robomongo 3. mongodb启动与连接3.1 windows启动服务器端1mongod --dbpath=./data 如果出现waiting for connections on port 27017就表示启动成功,已经在27017端口上监听了客户端的请求 注意：--dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经存在，否则服务开启失败 注意：这个命令窗体绝对不能关,关闭这个窗口就相当于停止了mongodb服务 也可以在命令后面加上参数 --port 27017 来指定端口 3.2 启动客户端连接服务器命令窗体中输入 mongo –host=127.0.0.1 或者 mongo 按回车键 备注：–host后的值表示服务器的ip地址 4. MongoDB基本概念 数据库 MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例 集合 数据库是由集合组成的,一个集合用来表示一个实体,如学生集合 文档 集合是由文档组成的，一个文档表示一条记录,比如一位同学张三就是一个文档 5. 数据库操作5.1 使用数据库语法1use database_name database_name代表数据库的名字 注：如果此数据库存在，则切换到此数据库下,如果此数据库还不存在也可以切过来 实例切换到 person数据库下 5.2 查看所有数据库语法1show dbs 备注: 我们刚创建的数据库person 如果不在列表内， 要显示它，我们需要向 person 数据库插入一些数据 db.person.insert({name:”zhangSan”,age:30}) 5.3 查看当前使用的数据库语法1db 或 db.getName() 注：db代表的是当前数据库 也就是person这个数据库 实例 5.4 删除数据库语法1db.dropDatabase() 实例 6. 集合操作6.1 查看帮助语法1db.worker.help() 实例 6.2 查看数据库下的集合语法1show collections 实例 6.3 创建集合创建一个空集合1db.createCollection(collection_Name) collection_Name集合的名称 创建集合并插入一个文档 collection_Name集合的名称 document要插入的文档 1db.collection_Name.insert(document) 7. 插入文档7.1 insert 语法12db.collection_name.insert(document)` 参数 collection_name 集合的名字 document 插入的文档 实例 每当插入一条新文档的时候mongodb会自动为此文档生成一个_id属性,_id一定是唯一的，用来唯一标识一个文档 _id也可以直接指定，但如果数据库中此集合下已经有此_id的话插入会失败 7.2 save 语法1db.collection_name.save(document) 参数 collection_name 集合的名字 document 插入的文档 注：如果不指定 _id 字段 save() 方法类似于 insert() 方法。如果指定 _id 字段，则会更新该 _id 的数据。 实例1db.person.save(&#123;name:&quot;xiaoHong&quot;,age:50&#125;) 1db.person.save(&#123;_id:ObjectId(&quot;562c9caf671c978b6596e825&quot;),name:&quot;xiaoHong&quot;,age:10&#125;) 8. 更新文档语法12345678db.collection.update( &lt;query&gt;, &lt;updateObj&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt; &#125;) 参数说明 query 查询条件,指定要更新符合哪些条件的文档 update 更新后的对象或指定一些更新的操作符 $set直接指定更新后的值 $inc在原基础上累加 upsert 可选，这个参数的意思是，如果不存在符合条件的记录时是否插入updateObj. 默认是false,不插入。 multi 可选，mongodb 默认只更新找到的第一条记录，如果这个参数为true,就更新所有符合条件的记录。 实例将document数据中name是liSi 的数据的name修改为liSi_update1db.worker.update(&#123;name:&apos;liSi&apos;&#125;,&#123;$set:&#123;name:&apos;liSi_update&apos;&#125;&#125;) 注：如果有多条name是liSi的数据只更新一条,如果想全部更新需要指定{multi:true}的参数 9. 文档的删除remove方法是用来移除集合中的数据 语法123456db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt; &#125;) 参数说明 query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除匹配到的多个文档中的第一个 实例删除worker集合里name是fJianZhou的所有Document数据1db.worker.remove(&#123;name:&apos;fJianZhou&apos;&#125;) 删除person集合里name是xiaoHong的第一条数据1db.person.remove(&#123;name:&quot;xiaoHong&quot;&#125;,1) 10. 查询文档10.1 find语法1db.collection_name.find() 参数 collection_name 集合的名字 实例查询worker下所有的文档1db.worker.find() 10.2 查询指定列语法1db.collection_name.find(&#123;queryWhere&#125;,&#123;key:1,key:1&#125;) 参数列表 collection_name 集合的名字 queryWhere 参阅查询条件操作符 key 指定要返回的列 1 表示要显示 实例1db.worker.find(&#123;&#125;,&#123;age:1&#125;) 查询指定列 10.3 findOne查询匹配结果的第一条数据语法1db.collection_name.findOne() 实例1db.worker.findOne() 11. 条件操作符条件操作符用于比较两个表达式并从mongoDB集合中获取数据 11.1 大于操作符语法1db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$gt:&lt;value&gt;&#125;&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例1db.worker.find(&#123;age:&#123;$gt:30&#125;&#125;) 查询age 大于 30的数据 11.2 大于等于操作符语法1db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例1db.worker.find(&#123;age: &#123;$gte: 30&#125;&#125;) 查询age 3大于等于30 的数据 11.3 小于操作符语法1db.collectoin_name.find( &#123;&lt;key&gt;:&#123;$lt:&lt;value&gt;&#125;&#125;) 参数 collectoin_name集合名称 key 字段 value 值 实例1db.worker.find(&#123;age: &#123;$lt: 30&#125;&#125;) 查询age 小于30的数据 11.4 小于等于操作符语法1db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;) 参数 collectoin_name集合名词 key字段 value值 实例1db.worker.find(&#123;age: &#123;$lte: 30&#125;&#125;) 查询age 小于等于30的数据 11.5 同时使用 $gte和$lte语法1db.collectoin_name.find(&#123;&lt;key&gt;:&#123;$gte:&lt;value&gt;&#125;,&lt;key&gt;:&#123;$lte:&lt;value&gt;&#125;&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例查询age 大于等于 30 并且 age 小于等于 50 的数据1db.worker.find(&#123;age: &#123;$gte: 30, $lte: 50&#125;&#125;) 11.6 等于语法1db.collectoin_name.find(&#123;&lt;key&gt;:&lt;value&gt;,&lt;key&gt;:&lt;value&gt;&#125;) 参数 collectoin_name集合名词 key字段 value值 实例查询age = 30的数据1db.worker.find(&#123;&quot;age&quot;: 30&#125;)` 11.7 使用 _id进行查询语法1db.collectoin_name.find(&#123;&quot;_id&quot; : ObjectId(&quot;value&quot;)&#125;) 参数 value _id的值 实例查询_id是 562af23062d5a57609133974 数据1db.worker.find(&#123;&quot;_id&quot; : ObjectId(&quot;562af23062d5a57609133974&quot;)&#125;) 11.8 查询结果集的条数语法1db.collectoin_name.find().count() 参数 collectoin_name 集合名称 实例1db.worker.find().count() 11.9 正则匹配语法1db.collection.find(&#123;key:/value/&#125;) 参数 collectoin_name 集合名称 key 字段 value 值 实例查询name里包含zhang的数据1db.worker.find(&#123;name:/value/&#125;) 查询某个字段的值当中是否以另一个值开头1db.worker.find(&#123;name:/^zhang/&#125;) 12. 与和或12.1 andfind方法可以传入多个键(key)，每个键(key)以逗号隔开 语法1db.collection_name.find(&#123;key1:value1, key2:value2&#125;) 实例查询name是zhangRenYang并且age是30的数据1db.worker.find(&#123;name:&apos;zhangRenYang&apos;,age:30&#125;) 12.2 or语法1234567db.collection_name.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;) 实例查询age = 30 或者 age = 50 的数据1db.worker.find(&#123;$or:[&#123;age = 30&#125;,&#123;age = 50&#125;]&#125;) 12.3 and和or联用语法12345678910db.collection_name.find( &#123; key1:value1, key2:value2, $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;) 实例查询 name是zhangRenYang 并且 age是30 或者 age是 50 的数据1db.worker.find(&#123;name:&apos;zhangRenYang&apos;,$or:[&#123;age:30&#125;,&#123;age:50&#125;]&#125;) 13. 分页查询13.1 limit读取指定数量的数据记录语法1db.collectoin_name.find().limit(number) 参数 collectoin_name集合 number读取的条数 实例查询前3条数据1db.worker.find().limit(3) 13.2 skip跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数语法1db.collectoin_name.find().skip(number) 参数 collectoin_name集合 number跳过的条数 实例查询3条以后的数据1db.worker.find().skip(3) 13.3 skip+limit通常用这种方式来实现分页功能语法1db.collectoin_name.find().skip(skipNum).limit(limitNum) 参数 collectoin_name 集合名称 skipNum 跳过的条数 limitNum 限制返回的条数 实例查询在4-6之间的数据1db.worker.find().sort(&#123;age:-1&#125;) 13.4 sort排序sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。语法12db.collectoin_name.find().sort(&#123;key:1&#125;)db.collectoin_name.find().sort(&#123;key:-1&#125;) 参数 collectoin_name集合 key表示字段 实例查询出并升序排序 {age:1} age表示按那个字段排序 1表示升序1db.worker.find().sort(&#123;age:1&#125;)","tags":[{"name":"mongodb","slug":"mongodb","permalink":"https://newming.github.io/tags/mongodb/"}]},{"title":"tail 命令","date":"2017-12-27T03:05:01.000Z","path":"2017/12/27/tail/","text":"用途:从指定点开始将文件写到标准输出。使用tail命令的-f选项可以方便的查阅正在改变的日志文件，tail -f filename会把filename里最尾部的内容显示在屏幕上，并且不但刷新，使你看到最新的文件内容。 tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。 Number 变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。如果值的前面有 +（加号），从文件开头指定的单元数开始将文件写到标准输出。如果值的前面有 -（减号），则从文件末尾指定的单元数开始将文件写到标准输出。如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。 Number 变量用于确定计数的起点的单元类型由 -b、-c、-k、-m 以及 -n 标志确定。如果没有指定其中的任何一个标志，那么 tail 命令就会读取指定文件的最后十行，并将其写到标准输出。这与在命令行输入 -n 10 是相同的。 12tail -h# tail [-F | -f | -r] [-q] [-b # | -c # | -n #] [file ...] 命令参数 -f: 循环读取 -q: 不现实处理信息 -v: 显示详细的处理信息 -c [number]: 显示的字节数 -n [number]: 显示的行数 -b [Number]: 从 Number 变量表示的 512 字节块位置开始读取指定文件 -r: 从文件末尾以逆序方式显示输出。-r 标志的缺省值是以逆序方式打印整个文件。如果文件大于 20,480 字节，那么 -r 标志只显示最后的 20,480 字节。-r 标志只有与 -n 标志一起时才有效。否则，就会将其忽略。而且 -r 在 -n 前 12345678# 显示 notes 文件的最后十行tail notes# 要从第 200 字节开始，每次显示一页 notes 文件tail -c +200 notes | pg# 跟踪文件变化，显示的是accounts最后十行，并持续监听tail -f accounts","tags":[{"name":"shell","slug":"shell","permalink":"https://newming.github.io/tags/shell/"}]},{"title":"dom 知识汇总","date":"2017-12-26T11:55:59.000Z","path":"2017/12/26/dom-model/","text":"DOM: Document object model 文档对象模型，描述整个html页面中节点关系的谱图。熟练操作 DOM 在我们的日常开发中非常重要。 js DOM元素获取的方法(8种)document.getElementById(‘id’)通过id获取元素，如果id重复了，获取到的是第一个，区分大小写（在 IE 6,7中不区分） 在 IE 6,7 中会把元素的 name 当作 id 来使用 如果没有获取到则返回 null,可以用id直接代表这个对象，而不去提前获取。上下文只能是 document1234// html&lt;p id='test'&gt;js中可以直接通过id拿到我&lt;/p&gt;// jsconsole.log(test); context.getElementsByTagName(‘li’)通过元素的标签名获取一组元素，有几个获取几个。可以根据上下文(context)获取我们获取元素的范围。 12document.getElementsByTagName('li');oDIv.getElementsByTagName('li'); document.getElementsByName(‘text’)通过元素的name属性获取一组元素 注意在 IE浏览器下只对表单元素起作用。这个方法常用于获取具有相同name的表单元素 context.getElementsByClassName(‘class’)在 IE 6~8 会报错 document.documentElement,document.body分别获取 html,body 元素，通常用来获取文档属性1var winW = document.documentElement.clientWidth || document.body.clientWidth // 兼容所有的浏览器获取当前浏览器宽度 document.querySelector,document.querySelectorAll在移动端常用的方法，IE6～8不支持。同时不存在映射关系 前者只获取一个元素，后者获取全部12345document.querySelector('#id')document.querySelector('.class')document.querySelector('li')document.querySelectorAll('#id li') // 后代选择器document.querySelectorAll(\"input[type='text']\") // 属性选择器 DOM 中的节点和关系属性w3chool的文档 获取关系的属性节点：node 一个html页面中的元素标签、文本、注释。。。都是节点。在标准浏览器下，空格和Enter（回车）都是文本节点1234567oBox.childNodes // 获取所有的子节点oBox.children // 获取所有的元素子节点oBox.parentNode // 获取元素的父亲节点oBox.previousSibling // 获取元素位于相同节点树层级的前一个元素，注意空格回车文本节点也会获取。(哥哥)oBox.nextSibling // 获取元素位于相同节点树层级的后一个元素。(弟弟)oBox.firstChild // 获取第一个子元素oBox.lastChild // 获取元素的最后一个 节点主要的节点类型及其属性。 节点类型 nodeType nodeName nodeValue 元素节点（元素标签） 1 大写的标签名 null 文本节点（文字） 3 #text 文字内容 注释节点 8 #comment 注释内容 document 9 #document null 小案例，模拟children方法模拟children方法，实现获取指定元素下所有的元素子节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1. 获取 children 标签元素 可以设置筛选function getChildren(ele,tagName) &#123; var ary = []; var nodes = ele.childNodes; // 拿到元素下所有的子节点 for (var i = 0; i &lt; nodes.length; i++) &#123; var cur = nodes[i]; if (cur.nodeType===1) &#123; if (tagName) &#123; // 如果传了tagName，再次筛选 if (cur.nodeName.toLowerCase() === tagName.toLowerCase()) &#123; // 注意nodeName是大写，但是传入的参数不确定，所有先都转为小写 ary.push(cur) &#125; &#125;else &#123; // 如果没传tagName，默认将所有的子元素节点返回 ary.push(cur) &#125; &#125; &#125; return ary;&#125;let box = document.getElementById('box');getChildren(document.getElementById(box, 'p'))// 2. 获取 children 标签元素 可以设置筛选，根据兼容处理function childern (curEle, tagName) &#123; var ary = [] if (/MSIE (6|7|8)/i.test(navigator.userAgent)) &#123; var nodes = ele.childNodes; for (var i = 0; i &lt; nodes.length; i++) &#123; var cur = nodes[i]; if (cur.nodeType === 1) &#123; ary.push(cur) &#125; &#125; nodes = null &#125; else &#123; ary = Array.prototype.slice.call(curEle.children) &#125; if (typeof tagName === 'string') &#123; for (var k = 0; k &lt; ary.length; k++) &#123; var curEle = ary[k] if (curEle.nodeName.toLowerCase() !== tagName.toLowerCase()) &#123; ary.splice(k, 1) k-- &#125; &#125; &#125; return ary&#125; 小案例，获取siblingshtml 结构123456789&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;!-- 我是注释 --&gt; &lt;li id='li3'&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;!-- 如何通过js获取到3的上一个兄弟2 --&gt;&lt;!-- 需要注意原生的 DOM 属性 previousSibling 会计算空格和回车还有注释等，所以往上找多少级不确定 --&gt; js 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// 1.获取上一个兄弟节点，兼容IEvar li3 = document.getElementById('li3')function prev(ele) &#123; var pre = ele.previousSibling; while (pre &amp;&amp; pre.nodeType !== 1) &#123; pre = pre.previousSibling; &#125; return pre&#125;prev(li3)// 2. 获取上一个兄弟节点，previousElementSibling 标准浏览器// 3.获取所有的上级兄弟节点var li3 = document.getElementById('li3')function prevAll(ele) &#123; var ary = []; var pre = ele.previousSibling; while (pre) &#123; if (pre.nodeType === 1) &#123; ary.unshift(pre) &#125; pre = pre.previousSibling; &#125; return ary&#125;prevAll(li3)// 4. 获取当前元素的索引function index(curEle) &#123; // 有几个哥哥就是几 var ary = []; var pre = curEle.previousElementSibling; while (pre) &#123; ary.unshift(pre) pre = pre.previousElementSibling; &#125; return ary.length&#125;// 5. firstchild 第一个元素节点function firstChild (parentNode) &#123; return parentNode.children[0] ? parentNode.children[0] : null&#125; DOM 增删改 document.createElement(‘div’); 动态创建一个标签元素 box.appendChild() 将元素添加到指定的容器中的末尾 insertBefore(newItem,existingItem) 把新的元素插入到老得元素之前，如果老元素不存在，会放到末尾 removeChild(item) 删除元素 cloneNode(true || false) 克隆元素默认false只克隆当前元素，true clone 子孙 replaceChild(newnode,oldnode) document.createDocumentFragment() 创建文档碎片 属性的增删改查 setAttribute() getAttribute() removeAttribute() 在IE 6~8 中不能修改class属性 box.className可以 1234567891011121314151617181920// 1. appendfunction append (newEle, container) &#123; container.appendChild(newEle)&#125;// 2. prependfunction prepend (newEle, container) &#123; var firstChild = container.children[0] ? parentNode.children[0] : null container.insertBefore(newEle, firstChild)&#125;// 3. insertBeforefunction insertBefore (newEle, oldEle) &#123; oldEle.parentNode.insertBefore(newEle, oldEle)&#125;// 4. insertAfterfunction insertAfter (newEle, oldEle) &#123; oldEle.parentNode.insertBefore(newEle, oldEle.nextElementSibling)&#125; dom 数据绑定方法1234567891011121314151617// 1. 通过 document.createElement 进行创建插入，会造成多次 dom 回流，即重新渲染 dom，造成性能浪费，不影响原有的 domdocument.createElementdocument.appendChild// 2. 字符串拼接，只需要一次回流，但是会造成原有的 dom 丢失事件绑定var str = '&lt;span&gt;aa&lt;/span&gt;'box.innerHTML = str// 3. 文档碎片var frg = document.createDocumentFragment() // 创建一个文档碎片相当于临时创建了一个容器for (var i = 0; i &lt; 5; i++) &#123; var oLi = document.createElement('li') oLi.innerHTML = i frg.appendChild(oLi)&#125;oUl.appendChild(frg) // 优点:不影响原有 li，一次回流frg = null 操作元素 class 属性12345678910111213141516171819202122232425262728293031// 1. hasClass 是否包含某个class，可以直接用 dom.classList.containsfunction hasClass (curEle, className) &#123; var reg = new RegExp('(^|\\\\s)' + className + '(\\\\s|$)') // var reg = new RegExp('(^| +)' + className + '( +|$)') return reg.test(curEle.className)&#125;// 2. addClass支持传多个class，以空格隔开，可以直接用 dom.classList.add(class,class,...)，不过存在兼容问题function addClass(curEle, className) &#123; var ary = className.replace(/(^ +| +$)/g, '').split(/ +/g) // split(' ') for (var i = 0; i &lt; ary.length; i++) &#123; var curClass = ary[i] if (!hasClass(curEle, curClass)) &#123; curEle.className += ' ' + curClass &#125; &#125;&#125;// 3. removeClass，支持传多个class，以空格隔开，可以直接用 dom.classList.remove(class, class, ...)，不过存在兼容问题function removeClass(curEle, className) &#123; var ary = className.replace(/(^ +| +$)/g, '').split(/ +/g) for (var i = 0; i &lt; ary.length; i++) &#123; var curClass = ary[i] if (hasClass(curEle, curClass)) &#123; var reg = new RegExp('(^| +)' + curClass + '( +|$)', 'g') curEle.className = curEle.className.replace(reg, ' ').trim() &#125; &#125;&#125; getElementsByClassName 的兼容处理12345678910111213141516171819202122232425// className: 要获取的元素的样式类名，可能一个也可能多个，多个之间用空格（几个都行）隔开// context: 获取元素的上下文，不传的话默认为 documentfunction getElementsByClass (className, context) &#123; context = context || document var classNameAry = className.replace(/(^ +| +$)/g, '').split(/ +/g) // 获取上下文包含的所有标签 var nodeList = context.getElementsByTagName('*') var ary = [] for (var i = 0; i &lt; nodeList.length; i++) &#123; var curNode = nodeList[i] var flag = true for (var k = 0; k &lt; classNameAry.length; k++) &#123; var reg = new RegExp('(^| +)' + classNameAry[k] + '( +|$)') if (!reg.test(curNode.className)) &#123; flag = false break &#125; &#125; if (flag) &#123; ary.push(curNode) &#125; &#125;&#125; 操作浏览器属性123456789// 两个参数，只传一个是获取，两个是设置function win (attr, val) &#123; if (typeof val === 'undefined') &#123; return document.documentElement[attr] || document.body[attr] &#125; else &#123; document.documentElement[attr] = val document.body[attr] = val &#125;&#125; 获取元素样式属性值 元素.style.属性：样式必须写在行内样式(不常用) 通过 window 提供的一个方法 getComputedStyle 来获取所有经过浏览器计算过的（只要当前元素标签可以在页面中呈现出来，那么它的样式都是经过浏览器的计算／渲染过的，哪怕有些样式没有写，同样可以获取）样式属性。IE 6,7,8 不兼容 在 IE 6,7,8 下使用 currentStyle 来获取元素的样式属性，不支持伪类 box.currentStyle[attr] 1234567891011121314151617181920212223// 第一个参数是要获取的 dom 元素，第二个是伪类，一般不用，获取到的是当前元素的所有的样式window.getComputedStyle('元素', '伪类')[attr]// 兼容，不同浏览器获取到的属性不一定相同，主要是 IE 的其他的问题function getStyle (element, attr) &#123; let val = null if ('getComputedStyle' in window) &#123; val = window.getComputedStyle(element)[attr] &#125; else &#123; // IE 6,7,8 if (attr === 'opacity') &#123; val = element.currentStyle['filter'] // 将数字除以 100 为标准浏览器的 opacity let reg = /^alpha\\(opacity=(\\d+(?:\\.\\d+)?)\\)$/i // 第二次升级：匹配 0-100 的整数或小数，将第一个分组捕获，?: 只匹配不捕获 val = reg.test(val) ? reg.exec(val)[1] / 100 : 1 &#125; else &#123; val = element.currentStyle[attr] &#125; &#125; let reg = /^(-?\\d+(\\.\\d+)?)(px|pt|rem|em)?$/i // 第一次升级：去掉数值单位，数字开头px,pt等单位结尾的单个数值 return reg.test(val) ? parseFloat(val) : val&#125;getStyle(box, 'width') // 需要去掉单位的功能getStyle(box, 'opacity') // IE 6-8 不设置这个属性，设置的是 filter: alpha(opacity=10) 修改 dom 样式在 js 中给元素设置样式属性值，我们只能通过 dom.style[attr] = value 这种方式给当前元素设置行内样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1. 单个样式设置。某些传递进来的值没有单位，把默认单位补上function setCss (curEle, attr, value) &#123; // 兼容 float 样式值 if (attr === 'float') &#123; curEle['style']['cssFloat'] = value curEle['style']['styleFloat'] = value return &#125; // 兼容 opacity if (attr === 'opacity') &#123; curEle['style'][attr] = value curEle['style']['filter'] = 'alpha(opacity=' + value * 100 + ')' return &#125; var reg = /^(width|height|top|bottom|left|right|((margin|padding)(Top|Bottom|Left|Right)?))$/ if (reg.test(attr)) &#123; if (!isNaN(value)) &#123; value += 'px' &#125; &#125; curEle['style'][attr] = value&#125;// 2. 批量设置样式function setGroupCss (curEle, options) &#123; options = options || 0 // 防止没传值的时候调用 toString 方法出错 // 检测 options 的数据类型 if (options.toString() !== '[object Object]') &#123; return &#125; for (var key in options) &#123; if (options.hasOwnProperty(key)) &#123; this.setCss(curEle, key, options[key]) &#125; &#125;&#125;// 3. 模拟 jquery 中的 css 方法。实现获取，单独设置，批量设置元素的样式function css (curEle) &#123; var argTwo = arguments[1] var ary = Array.prototype.slice.call(arguments, 1) if (typeof argTwo === 'string') &#123; var argThree = arguments[2] if (typeof argThree === 'undefined') &#123; // 第三个参数可能是数字 0，所以这里必须是 undefined return getStyle(curEle, argTwo) &#125; setCss.apply(curEle, ary) // this.setCss(curEle, argTwo, argThree) return &#125; // 设置多个样式 argTwo = argTwo || 0 if (argTwo.toString() === '[object Object]') &#123; setGroupCss.apply(curEle, ary) &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"网站升级 HTTPS","date":"2017-12-23T10:03:26.000Z","path":"2017/12/23/enable-mysite-https/","text":"哈哈，从今天开始，我的网站正式升级 https，从此不在被可恶的运营商注入广告了。这里主要记录一下繁琐的升级过程。 首先要感谢耗子哥的文章以及免费的 https 证书提供机构let’s Encrypt，当然还有很多其他文章的指导。 目前我关注的网站主要是两个，一个是放到自己服务器上的主站，另一个是托管到 github 的博客，由于博客是托管到 github 的，当时为了访问方便，做了 CNAME，绑定到了 newming.cn 上，而绑定方案是通过 dns 服务商处将 newming.cn 的记录直接指向了我的 github 博客的 ip，所以，如果要给博客升级 https 就不能在这么做了。 第一步: 反向代理 gh-pages参考文章 第一步要做的就是将我的 dns 配置中以前指向 GitHub 的两条记录停掉，转而指向我的服务器。 第二部就是在我的服务器上去增加 newming.cn 这个域名的配置了，具体代码如下： 123456789101112server &#123; listen 80; server_name newming.cn; location / &#123; proxy_pass https://newming.github.io; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 配置完成之后直接 sudo nginx -s reload 重启即可 第二步: 部署 https参考文章 这里直接按文章步骤执行即可，其中在执行 sudo certbot --nginx 有些需要可选项可以根据自己情况选择，比如是否强制跳转 https，这里我选择的是，当然你也可以在之后自行修改 nginx 配置文件。 第三步: 升级 nginx因为开启 http2需要高版本的 nginx，所以就做了一个 nginx 升级，如果你的配置文件较为重要，请提前备份，这里我备份了 /etc/nginx/nginx.conf 文件，不过后来发现，再升级的时候 nginx 会自动给我备份出来一个 /etc/nginx/nginx.conf.dpkg-old 文件。升级中同样会有一些选择，其中有一个是否使用最新的配置文件，这里我选了是，之后一路平坦。 123sudo add-apt-repository ppa:nginx/stablesudo apt-get updatesudo apt-get install nginx 至此，折腾完毕，整整一下午过去了。生命不止，折腾不止。","tags":[{"name":"nginx","slug":"nginx","permalink":"https://newming.github.io/tags/nginx/"}]},{"title":"position-sticky","date":"2017-12-19T06:02:30.000Z","path":"2017/12/19/position-sticky/","text":"今天带来的是一个逆天的 css 属性，position: sticky。粘性定位。 相信大家对 css 中 position 属性的用法不陌生，那么今天这个属性是做什么的呢？他就是用来做吸顶的效果的，不需要 js 计算，只需要两条 css 属性即可。 请看下方效果，标题 A,C,E,T等自动吸顶。 See the Pen 粘性定位 by newming (@newming) on CodePen. 其中核心代码就只有两句 css。其中 top 为吸顶效果的边界值。我们可以想像成加了 sticky 属性后，这个元素会自动去按照我们的给定的边界值计算，具体表现为什么。具体来说就是按照 position: fixed; 来算。比如例子中，当标题 fixed 后，它当前的位置的值如果比我们给定的 -1px 小，就表现为 fixed 的效果，如果大于 -1px，表现为 relative 效果 12position: sticky;top: -1px; 综上，sticky 会变现出两种其他 position 效果，当小于边界值，为 fixed，反之则 relative。有个蛋疼的地方是： android 表现不佳。","tags":[{"name":"css","slug":"css","permalink":"https://newming.github.io/tags/css/"}]},{"title":"自定义 range input 样式","date":"2017-12-15T04:44:02.000Z","path":"2017/12/15/custom-range-style/","text":"最近由于业务需求需要做一个控制音量的滑块按钮组件，由于 js 实现起来比较复杂，需要考虑 touch 和 click 之间的切换。所以决定使用 h5 新增的 input range 来实现，只要改掉其默认样式就好。 几番搜索之后找到了 css tricks 的一篇文章，非常不错，所以再此简单记录顺带翻译(-_^)一下。（准不准确不好说） 首先统一一下说法，range input 有两部分，可以拖动的叫滑块(thumb)，底部的是 track 第一步：去掉默认样式需要根据浏览器需要处理他们不同的默认样式，这里需要覆盖好几条样式属性。 1234567891011121314151617181920212223input[type=range] &#123; -webkit-appearance: none; /* 去掉底部的 track 默认样式，就是整个灰条 */ width: 100%; /* Firefox 需要指定明确的宽度 */ background: transparent; /* 否则在 Chrome 中是白色背景 */&#125;/* 去掉 webkit 内核 滑块 的样式 */input[type=range]::-webkit-slider-thumb &#123; -webkit-appearance: none;&#125;input[type=range]:focus &#123; outline: none; /* 去除获取焦点时蓝色的外边框，你也可以自己定制其他你想要的效果 */&#125;input[type=range]::-ms-track &#123; width: 100%; cursor: pointer; /* 这个是 IE 的 track 样式，没验证过 */ background: transparent; border-color: transparent; color: transparent;&#125; 到此我们已经有了一个兼容各浏览器的看不见的或者说没有样式的 range input。现在我们开始添加自定义的样式 第二步：给滑块增加样式你点击或者拖拽的那个小玩意叫做滑块（thumb），它就像一个普通的 HTML 元素一样可以被定义各种样式。 12345678910111213141516171819202122232425262728293031323334/* WebKit/Blink 样式定义 */input[type=range]::-webkit-slider-thumb &#123; -webkit-appearance: none; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; margin-top: -14px; /* 在 Chrome 中你需要给定一个明确的 margin，但是在 Firefox 和 IE 中这个是固定的 */ box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; /* 添加一条炫酷的效果为你的 thumb */&#125;/* Firefox 同上 */input[type=range]::-moz-range-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer;&#125;/* IE 同上 */input[type=range]::-ms-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer;&#125; 注意我们重复的写了很多代码，但这是必须的，你不能使用逗号去分割这几个选择器。浏览器会忽略全部的选择器如果逗号连接的部分中存在它不识别的。 现在我们的滑块是这个样子的: 第三步：给 track 添加样式thumb 所在的可滑动的那条线就是 track，它也像一个普通的 HTML 元素一样可以被定义各种样式。 在 IE 中需要注意：IE 10 以上有一些细微的不同表现。在 IE 中，你可以为 track 分别定义 thumb 左(lower)右(upper) 两边的样式。 另外需要注意的是你可以添加 track 的 focus 效果，当用户与 range input 进行交互的时候 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051input[type=range]::-webkit-slider-runnable-track &#123; width: 100%; height: 8.4px; cursor: pointer; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101;&#125;input[type=range]:focus::-webkit-slider-runnable-track &#123; background: #367ebd;&#125;input[type=range]::-moz-range-track &#123; width: 100%; height: 8.4px; cursor: pointer; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101;&#125;input[type=range]::-ms-track &#123; width: 100%; height: 8.4px; cursor: pointer; background: transparent; border-color: transparent; border-width: 16px 0; color: transparent;&#125;input[type=range]::-ms-fill-lower &#123; background: #2a6495; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;&#125;input[type=range]:focus::-ms-fill-lower &#123; background: #3071a9;&#125;input[type=range]::-ms-fill-upper &#123; background: #3071a9; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;&#125;input[type=range]:focus::-ms-fill-upper &#123; background: #367ebd;&#125; 现在你的 track 看起来是这样的： 最后：完整的 Range Input我们在上边已经创建了一个 thumb 和一个 track，我们可以将 css 进行合并。 完整的 css 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788input[type=range] &#123; -webkit-appearance: none; margin: 18px 0; width: 100%;&#125;input[type=range]:focus &#123; outline: none;&#125;input[type=range]::-webkit-slider-runnable-track &#123; width: 100%; height: 8.4px; cursor: pointer; animate: 0.2s; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101;&#125;input[type=range]::-webkit-slider-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer; -webkit-appearance: none; margin-top: -14px;&#125;input[type=range]:focus::-webkit-slider-runnable-track &#123; background: #367ebd;&#125;input[type=range]::-moz-range-track &#123; width: 100%; height: 8.4px; cursor: pointer; animate: 0.2s; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; background: #3071a9; border-radius: 1.3px; border: 0.2px solid #010101;&#125;input[type=range]::-moz-range-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer;&#125;input[type=range]::-ms-track &#123; width: 100%; height: 8.4px; cursor: pointer; animate: 0.2s; background: transparent; border-color: transparent; border-width: 16px 0; color: transparent;&#125;input[type=range]::-ms-fill-lower &#123; background: #2a6495; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;&#125;input[type=range]::-ms-fill-upper &#123; background: #3071a9; border: 0.2px solid #010101; border-radius: 2.6px; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d;&#125;input[type=range]::-ms-thumb &#123; box-shadow: 1px 1px 1px #000000, 0px 0px 1px #0d0d0d; border: 1px solid #000000; height: 36px; width: 16px; border-radius: 3px; background: #ffffff; cursor: pointer;&#125;input[type=range]:focus::-ms-fill-lower &#123; background: #3071a9;&#125;input[type=range]:focus::-ms-fill-upper &#123; background: #367ebd;&#125; 完整的效果如下： 更多内容请阅读 原文","tags":[{"name":"css","slug":"css","permalink":"https://newming.github.io/tags/css/"}]},{"title":"IT 必备词汇","date":"2017-11-03T02:10:29.000Z","path":"2017/11/03/words-for-it/","text":"This document will put some words in common usage serial 连续的（中间件的处理，one after another） parallel 平行的 exected 执行 faded 消失 reliable 可靠地 secure 安全的 offine mode 离线模式 deterministic 确定性 network performance 网络性能 queue up 排队 avoid 避免 upgrade 升级 continuous integration 持续集成 authority 权利，权限 authorise 授权，批准，委托 stability: 稳定性 standard: 标准的 constant: n常量 variable: n变量 dictionary: n字典 integer: n整数，整型 keyword n关键字 static: adj静态的 class: n 类 subclass: n 子类 superclass: n父类 polymorphism: n多态 inherit v继承 inheritance: n继承 interface: n接口 structure: n结构 instance: n 实例 property: n 属性 enumeration: n枚举 function: n 函数 parameter: n 参数 functionality: n功能 method: n 方法 element: n元素 call: v 调用 random: adj 随机的 generate: v产生，生成 generator: n生成器 implement: v实现 implementation: n实现 expression: n表达式 scope: n 范围 区域 initial: adj 最初的 initializer: n 初始化方法 initialization n初始化 deinitializer: n析构方法 item: n 项目; 条，条款; 一则 encapsulate: v封装 protocol: n 协议 delegate: v代理 delegation: n 代理 extend: v 拓展 extension: n拓展 external: adj 外部的 conform: v 遵守，遵照，遵循 iterate: v迭代 loop: n 循环 downcast: v向下转型 unwrap: v 拆箱 force-unwrap: v 强制拆箱 statement: n声明 optional: adj 可选的 code snippet: n 代码片段 define: v 定义 definition: n定义 contain: v 包含 query: v查询 particular: adj 特定的 type casting: 类型转换 cast: v 转换 operator: n 操作符 hierarchy: n 层次体系 subscript: n脚本 comma: n冒号 access: v访问，获取 exclamation mark: n感叹号 assign: v 赋值 assignment: n赋值 increase: v 增加 ，增大，增多 increasement: n 增加 ，增大，增多 decrease: v减少，减小 decreasement: v 减少，减小 global: adj 全局的 closure: n闭包 allocate: v分配 memory: n内存 reference: n引用 observe: v观察 observer: n观察者 modify: v修改 format: n格式 sort: v排序 nested: adj 嵌套的 reuse: v复用，重用 entity: n实体 public: adj 公共的，公开的 private: adj 私有的 internal: adj内部的 framework: n框架 unit test: 单元测试 associate: v关联 generic: n 范型 collection: n集合 swap: v交换 original: adj初始的 compile: v编译 characteristic: n性质 override: v重写，复写 overload: v重载 index: n索引 syntax: n语法","tags":[{"name":"English","slug":"English","permalink":"https://newming.github.io/tags/English/"}]},{"title":"数组排序算法","date":"2017-09-21T01:53:16.000Z","path":"2017/09/21/arrsort/","text":"简单实现3种数组排序 冒泡排序 快速排序 插入排序 冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445var arr = [12,10,13,8,4];// target: [4,8,10,12,13] 从小到大排序// 思想：当前项和后一项进行比较，如果当前项大于后一项，两者交换位置/* 第一轮比较四次，将最大的已经放到最后了，接下来下一轮，一共需要arr.length-1轮 [10,12,13,8,4] [10,12,13,8,4] [10,12,8,13,4] [10,12,8,4,13] 接下来第二轮比较三次 i控制轮数，从0开始的话 i=0第一轮 比较arr.length-1-0次 i=1第一轮 比较arr.length-1-1次 i=2第一轮 比较arr.length-1-2次 ... i=n第n轮 比较arr.length-1-n次 当当前项大于后一下交换位置 var a = 12; var b = 13; var c = null; c = a; a = b; b = c*/function sortAry(ary)&#123; // i代表轮数，比较ary.length-1次 for (var i = 0; i &lt; ary.length-1; i++) &#123; // 比较arr.length-1-i次，j代表每一轮比较的次数,不用和自己比，不用和上一轮最后一项的最大值比较 for (var j = 0; j &lt; ary.length-1-i; j++) &#123; var cur = ary[j],next = ary[j+1]; if (cur&gt;next) &#123; // 如果当前项大于下一项，交换位置 var temp = null; temp = ary[j]; ary[j] = ary[j+1]; ary[j+1] = temp; &#125; &#125; &#125;&#125;sortAry(arr)console.log(arr); 快速排序从数组的中间拿一个值，然后通过这个值挨个和数组里面的值进行比较，如果大于的放一边，小于的放一边，然后把这些合并，再进行比较，如此反复即可。 123456789101112131415161718192021222324252627var arr = [3,1,4,2,5,21,6,15,63];function sortA(arr)&#123; // 如果只有一位，就没有必要比较 if(arr.length&lt;=1)&#123; return arr; &#125; // 获取中间值的索引 var len = Math.floor(arr.length/2); // 截取中间值 var cur = arr.splice(len,1); // 小于中间值放这里面 var left = []; // 大于的放着里面 var right = []; for(var i=0;i&lt;arr.length;i++)&#123; // 判断是否大于 if(cur&gt;arr[i])&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; // 通过递归，上一轮比较好的数组合并，并且再次进行比较。 return sortA(left).concat(cur,sortA(right)); console.log(sortA(left).concat(cur,sortA(right)););&#125;console.log(sortA(arr)); 额，理解起来比较难，画了个图 插入排序(INSERTION-SORT)插入排序：对于少量元素比较有效。 12345678910111213141516171819202122232425262728function sort(elements)&#123; //假设第0个元素是一个有序的数列，第1个以后的是无序的序列， //所以从第1个元素开始将无序数列的元素插入到有序数列中 for(var i = 1; i &lt; elements.length; i++)&#123; //升序 if(elements[i] &lt; elements[i-1])&#123; //取出无序数列中的第i个作为被插入元素 var guard = elements[i]; //记住有序数列的最后一个位置，并且将有序数列位置扩大一个 var j = i - 1; // elements[i] = elements[j]; // 我发现这句是多余的 //比大小，找到被插入元素所在的位置 while(j &gt;= 0 &amp;&amp; guard &lt; elements[j])&#123; elements[j+1] = elements[j]; j--; &#125; //插入 elements[j+1] = guard; &#125; &#125;&#125;var elements = [10, 9, 8, 7, 6, 5];console.log('before: ' + elements);sort(elements);console.log(' after: ' + elements);","tags":[{"name":"js","slug":"js","permalink":"https://newming.github.io/tags/js/"}]},{"title":"introduce","date":"2017-09-07T04:59:46.000Z","path":"2017/09/07/introduce/","text":"关于本博客介绍 额，目前定位为自己的一个写笔记的地方，不知道将来写不写。","tags":[]}]